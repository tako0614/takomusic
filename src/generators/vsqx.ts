// VSQX (Vocaloid Sequence XML) generator for vocal tracks

import type { SongIR, VocalTrack, NoteEvent } from '../types/ir.js';

export function generateVsqx(ir: SongIR): string {
  const vocalTracks = ir.tracks.filter((t): t is VocalTrack => t.kind === 'vocal');

  const tempo = ir.tempos[0]?.bpm ?? 120;
  const timeSig = ir.timeSigs[0] ?? { numerator: 4, denominator: 4 };

  let xml = `<?xml version="1.0" encoding="UTF-8"?>
<vsq4 xmlns="http://www.yamaha.co.jp/vocaloid/schema/vsq4/">
  <vender><![CDATA[Yamaha Corporation]]></vender>
  <version><![CDATA[4.0.0.0]]></version>
  <vVoiceTable>
`;

  // Add voice definitions
  for (let i = 0; i < vocalTracks.length; i++) {
    const track = vocalTracks[i];
    const voiceName = track.meta.voice ?? 'MIKU_V4X';
    xml += `    <vVoice>
      <bs>0</bs>
      <pc>0</pc>
      <id><![CDATA[${voiceName}]]></id>
      <name><![CDATA[${voiceName}]]></name>
      <vPrm>
        <bre>0</bre>
        <bri>0</bri>
        <cle>0</cle>
        <gen>0</gen>
        <ope>0</ope>
      </vPrm>
    </vVoice>
`;
  }

  xml += `  </vVoiceTable>
  <mixer>
    <masterUnit>
      <oDev>0</oDev>
      <rLvl>0</rLvl>
      <vol>0</vol>
    </masterUnit>
`;

  // Add mixer units for each track
  for (let i = 0; i < vocalTracks.length; i++) {
    xml += `    <vsUnit>
      <tNo>${i}</tNo>
      <iGin>0</iGin>
      <sLvl>-898</sLvl>
      <sDur>64</sDur>
      <vol>0</vol>
      <pan>64</pan>
    </vsUnit>
`;
  }

  xml += `  </mixer>
  <masterTrack>
    <seqName><![CDATA[${escapeXml(ir.title ?? 'Untitled')}]]></seqName>
    <comment><![CDATA[Generated by MusicForge]]></comment>
    <resolution>${ir.ppq}</resolution>
    <preMeasure>1</preMeasure>
    <timeSig>
      <m>0</m>
      <nu>${timeSig.numerator}</nu>
      <de>${timeSig.denominator}</de>
    </timeSig>
    <tempo>
      <t>0</t>
      <v>${Math.round(tempo * 100)}</v>
    </tempo>
  </masterTrack>
`;

  // Add vocal tracks
  for (let i = 0; i < vocalTracks.length; i++) {
    const track = vocalTracks[i];
    xml += generateVsqxTrack(track, i, ir.ppq);
  }

  xml += `</vsq4>
`;

  return xml;
}

function generateVsqxTrack(track: VocalTrack, index: number, ppq: number): string {
  const notes = track.events.filter((e): e is NoteEvent => e.type === 'note');

  let xml = `  <vsTrack>
    <tNo>${index}</tNo>
    <name><![CDATA[${escapeXml(track.name)}]]></name>
    <comment><![CDATA[]]></comment>
    <vsPart>
      <t>0</t>
      <playTime>${getEndTick(notes, ppq)}</playTime>
      <name><![CDATA[Part ${index + 1}]]></name>
      <comment><![CDATA[]]></comment>
      <sPlug>
        <id><![CDATA[ACA9C502-A04B-42b5-B2EB-5CEA36D16FCE]]></id>
        <name><![CDATA[VOCALOID2 Compatible Style]]></name>
        <version><![CDATA[3.0.0.1]]></version>
      </sPlug>
      <pStyle>
        <v id="accent">50</v>
        <v id="bendDep">8</v>
        <v id="bendLen">0</v>
        <v id="decay">50</v>
        <v id="fallPort">0</v>
        <v id="opening">127</v>
        <v id="risePort">0</v>
      </pStyle>
      <singer>
        <t>0</t>
        <bs>0</bs>
        <pc>0</pc>
      </singer>
`;

  // Add notes
  for (const note of notes) {
    xml += `      <note>
        <t>${note.tick}</t>
        <dur>${note.dur}</dur>
        <n>${note.key}</n>
        <v>64</v>
        <y><![CDATA[${escapeXml(note.lyric ?? 'a')}]]></y>
        <p><![CDATA[${getLyricPhoneme(note.lyric ?? 'a')}]]></p>
        <nStyle>
          <v id="accent">50</v>
          <v id="bendDep">8</v>
          <v id="bendLen">0</v>
          <v id="decay">50</v>
          <v id="fallPort">0</v>
          <v id="opening">127</v>
          <v id="risePort">0</v>
          <v id="vibLen">0</v>
          <v id="vibType">0</v>
        </nStyle>
      </note>
`;
  }

  xml += `    </vsPart>
  </vsTrack>
`;

  return xml;
}

function getEndTick(notes: NoteEvent[], ppq: number): number {
  if (notes.length === 0) {
    return ppq * 4; // One measure
  }

  let maxEnd = 0;
  for (const note of notes) {
    const end = note.tick + note.dur;
    if (end > maxEnd) {
      maxEnd = end;
    }
  }

  // Round up to next measure
  const ticksPerMeasure = ppq * 4;
  return Math.ceil(maxEnd / ticksPerMeasure) * ticksPerMeasure;
}

function getLyricPhoneme(lyric: string): string {
  // Basic Japanese to phoneme mapping
  // This is a simplified version - real implementation would need
  // a proper phoneme dictionary
  const hiraganaToPhoneme: Record<string, string> = {
    'あ': 'a', 'い': 'i', 'う': 'M', 'え': 'e', 'お': 'o',
    'か': 'k a', 'き': 'k i', 'く': 'k M', 'け': 'k e', 'こ': 'k o',
    'さ': 's a', 'し': 'S i', 'す': 's M', 'せ': 's e', 'そ': 's o',
    'た': 't a', 'ち': 'tS i', 'つ': 'ts M', 'て': 't e', 'と': 't o',
    'な': 'n a', 'に': 'J i', 'ぬ': 'n M', 'ね': 'n e', 'の': 'n o',
    'は': 'h a', 'ひ': 'C i', 'ふ': 'p M', 'へ': 'h e', 'ほ': 'h o',
    'ま': 'm a', 'み': 'm i', 'む': 'm M', 'め': 'm e', 'も': 'm o',
    'や': 'j a', 'ゆ': 'j M', 'よ': 'j o',
    'ら': '4 a', 'り': '4 i', 'る': '4 M', 'れ': '4 e', 'ろ': '4 o',
    'わ': 'w a', 'を': 'o', 'ん': 'N',
    'が': 'g a', 'ぎ': 'g i', 'ぐ': 'g M', 'げ': 'g e', 'ご': 'g o',
    'ざ': 'dz a', 'じ': 'dZ i', 'ず': 'dz M', 'ぜ': 'dz e', 'ぞ': 'dz o',
    'だ': 'd a', 'ぢ': 'dZ i', 'づ': 'dz M', 'で': 'd e', 'ど': 'd o',
    'ば': 'b a', 'び': 'b i', 'ぶ': 'b M', 'べ': 'b e', 'ぼ': 'b o',
    'ぱ': 'p a', 'ぴ': 'p i', 'ぷ': 'p M', 'ぺ': 'p e', 'ぽ': 'p o',
  };

  // Try to find phoneme for each character
  let phonemes: string[] = [];
  for (const char of lyric) {
    const phoneme = hiraganaToPhoneme[char];
    if (phoneme) {
      phonemes.push(phoneme);
    } else {
      // Default to 'a' for unknown characters
      phonemes.push('a');
    }
  }

  return phonemes.join(' ');
}

function escapeXml(str: string): string {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
}
