// VSQX (Vocaloid Sequence XML) generator for vocal tracks

import type { SongIR, VocalTrack, NoteEvent } from '../types/ir.js';

export function generateVsqx(ir: SongIR): string {
  const vocalTracks = ir.tracks.filter((t): t is VocalTrack => t.kind === 'vocal');

  const defaultTempo = ir.tempos[0]?.bpm ?? 120;
  const defaultTimeSig = ir.timeSigs[0] ?? { numerator: 4, denominator: 4 };

  let xml = `<?xml version="1.0" encoding="UTF-8"?>
<vsq4 xmlns="http://www.yamaha.co.jp/vocaloid/schema/vsq4/">
  <vender><![CDATA[Yamaha Corporation]]></vender>
  <version><![CDATA[4.0.0.0]]></version>
  <vVoiceTable>
`;

  // Add voice definitions
  for (let i = 0; i < vocalTracks.length; i++) {
    const track = vocalTracks[i];
    const voiceName = track.meta.voice ?? 'MIKU_V4X';
    xml += `    <vVoice>
      <bs>0</bs>
      <pc>0</pc>
      <id><![CDATA[${voiceName}]]></id>
      <name><![CDATA[${voiceName}]]></name>
      <vPrm>
        <bre>0</bre>
        <bri>0</bri>
        <cle>0</cle>
        <gen>0</gen>
        <ope>0</ope>
      </vPrm>
    </vVoice>
`;
  }

  xml += `  </vVoiceTable>
  <mixer>
    <masterUnit>
      <oDev>0</oDev>
      <rLvl>0</rLvl>
      <vol>0</vol>
    </masterUnit>
`;

  // Add mixer units for each track
  for (let i = 0; i < vocalTracks.length; i++) {
    xml += `    <vsUnit>
      <tNo>${i}</tNo>
      <iGin>0</iGin>
      <sLvl>-898</sLvl>
      <sDur>64</sDur>
      <vol>0</vol>
      <pan>64</pan>
    </vsUnit>
`;
  }

  xml += `  </mixer>
  <masterTrack>
    <seqName><![CDATA[${escapeXml(ir.title ?? 'Untitled')}]]></seqName>
    <comment><![CDATA[Generated by TakoMusic v1.0.0-alpha]]></comment>
    <resolution>${ir.ppq}</resolution>
    <preMeasure>1</preMeasure>
`;

  // Add all time signature events
  if (ir.timeSigs.length === 0) {
    xml += `    <timeSig>
      <m>0</m>
      <nu>${defaultTimeSig.numerator}</nu>
      <de>${defaultTimeSig.denominator}</de>
    </timeSig>
`;
  } else {
    for (const ts of ir.timeSigs) {
      const measureNum = Math.floor(ts.tick / (ir.ppq * 4));
      xml += `    <timeSig>
      <m>${measureNum}</m>
      <nu>${ts.numerator}</nu>
      <de>${ts.denominator}</de>
    </timeSig>
`;
    }
  }

  // Add all tempo events
  if (ir.tempos.length === 0) {
    xml += `    <tempo>
      <t>0</t>
      <v>${Math.round(defaultTempo * 100)}</v>
    </tempo>
`;
  } else {
    for (const t of ir.tempos) {
      xml += `    <tempo>
      <t>${t.tick}</t>
      <v>${Math.round(t.bpm * 100)}</v>
    </tempo>
`;
    }
  }

  xml += `  </masterTrack>
`;

  // Add vocal tracks
  for (let i = 0; i < vocalTracks.length; i++) {
    const track = vocalTracks[i];
    xml += generateVsqxTrack(track, i, ir.ppq);
  }

  xml += `</vsq4>
`;

  return xml;
}

function generateVsqxTrack(track: VocalTrack, index: number, ppq: number): string {
  const notes = track.events.filter((e): e is NoteEvent => e.type === 'note');

  let xml = `  <vsTrack>
    <tNo>${index}</tNo>
    <name><![CDATA[${escapeXml(track.name)}]]></name>
    <comment><![CDATA[]]></comment>
    <vsPart>
      <t>0</t>
      <playTime>${getEndTick(notes, ppq)}</playTime>
      <name><![CDATA[Part ${index + 1}]]></name>
      <comment><![CDATA[]]></comment>
      <sPlug>
        <id><![CDATA[ACA9C502-A04B-42b5-B2EB-5CEA36D16FCE]]></id>
        <name><![CDATA[VOCALOID2 Compatible Style]]></name>
        <version><![CDATA[3.0.0.1]]></version>
      </sPlug>
      <pStyle>
        <v id="accent">50</v>
        <v id="bendDep">8</v>
        <v id="bendLen">0</v>
        <v id="decay">50</v>
        <v id="fallPort">0</v>
        <v id="opening">127</v>
        <v id="risePort">0</v>
      </pStyle>
      <singer>
        <t>0</t>
        <bs>0</bs>
        <pc>0</pc>
      </singer>
`;

  // Add notes
  for (const note of notes) {
    // Map velocity 0-127 to VSQX velocity (typically 0-127)
    const velocity = note.vel ?? 64;
    // Calculate accent based on velocity deviation from default (64)
    const accent = Math.min(127, Math.max(0, 50 + Math.floor((velocity - 64) / 2)));

    xml += `      <note>
        <t>${note.tick}</t>
        <dur>${note.dur}</dur>
        <n>${note.key}</n>
        <v>${velocity}</v>
        <y><![CDATA[${escapeXml(note.lyric ?? 'a')}]]></y>
        <p><![CDATA[${getLyricPhoneme(note.lyric ?? 'a')}]]></p>
        <nStyle>
          <v id="accent">${accent}</v>
          <v id="bendDep">8</v>
          <v id="bendLen">0</v>
          <v id="decay">50</v>
          <v id="fallPort">0</v>
          <v id="opening">127</v>
          <v id="risePort">0</v>
          <v id="vibLen">66</v>
          <v id="vibType">0</v>
        </nStyle>
      </note>
`;
  }

  xml += `    </vsPart>
  </vsTrack>
`;

  return xml;
}

function getEndTick(notes: NoteEvent[], ppq: number): number {
  if (notes.length === 0) {
    return ppq * 4; // One measure
  }

  let maxEnd = 0;
  for (const note of notes) {
    const end = note.tick + note.dur;
    if (end > maxEnd) {
      maxEnd = end;
    }
  }

  // Round up to next measure
  const ticksPerMeasure = ppq * 4;
  return Math.ceil(maxEnd / ticksPerMeasure) * ticksPerMeasure;
}

function getLyricPhoneme(lyric: string): string {
  // Comprehensive Japanese to phoneme mapping for Vocaloid
  const hiraganaToPhoneme: Record<string, string> = {
    // Basic vowels
    'あ': 'a', 'い': 'i', 'う': 'M', 'え': 'e', 'お': 'o',
    // K row
    'か': 'k a', 'き': 'k i', 'く': 'k M', 'け': 'k e', 'こ': 'k o',
    'きゃ': 'k\' a', 'きゅ': 'k\' M', 'きょ': 'k\' o',
    // S row
    'さ': 's a', 'し': 'S i', 'す': 's M', 'せ': 's e', 'そ': 's o',
    'しゃ': 'S a', 'しゅ': 'S M', 'しょ': 'S o',
    // T row
    'た': 't a', 'ち': 'tS i', 'つ': 'ts M', 'て': 't e', 'と': 't o',
    'ちゃ': 'tS a', 'ちゅ': 'tS M', 'ちょ': 'tS o',
    // N row
    'な': 'n a', 'に': 'J i', 'ぬ': 'n M', 'ね': 'n e', 'の': 'n o',
    'にゃ': 'J a', 'にゅ': 'J M', 'にょ': 'J o',
    // H row
    'は': 'h a', 'ひ': 'C i', 'ふ': 'p\\ M', 'へ': 'h e', 'ほ': 'h o',
    'ひゃ': 'C a', 'ひゅ': 'C M', 'ひょ': 'C o',
    // M row
    'ま': 'm a', 'み': 'm i', 'む': 'm M', 'め': 'm e', 'も': 'm o',
    'みゃ': 'm\' a', 'みゅ': 'm\' M', 'みょ': 'm\' o',
    // Y row
    'や': 'j a', 'ゆ': 'j M', 'よ': 'j o',
    // R row
    'ら': '4 a', 'り': '4 i', 'る': '4 M', 'れ': '4 e', 'ろ': '4 o',
    'りゃ': '4\' a', 'りゅ': '4\' M', 'りょ': '4\' o',
    // W row
    'わ': 'w a', 'を': 'o', 'ん': 'N',
    // G row (voiced)
    'が': 'g a', 'ぎ': 'g i', 'ぐ': 'g M', 'げ': 'g e', 'ご': 'g o',
    'ぎゃ': 'g\' a', 'ぎゅ': 'g\' M', 'ぎょ': 'g\' o',
    // Z row (voiced)
    'ざ': 'dz a', 'じ': 'dZ i', 'ず': 'dz M', 'ぜ': 'dz e', 'ぞ': 'dz o',
    'じゃ': 'dZ a', 'じゅ': 'dZ M', 'じょ': 'dZ o',
    // D row (voiced)
    'だ': 'd a', 'ぢ': 'dZ i', 'づ': 'dz M', 'で': 'd e', 'ど': 'd o',
    // B row (voiced)
    'ば': 'b a', 'び': 'b i', 'ぶ': 'b M', 'べ': 'b e', 'ぼ': 'b o',
    'びゃ': 'b\' a', 'びゅ': 'b\' M', 'びょ': 'b\' o',
    // P row (semi-voiced)
    'ぱ': 'p a', 'ぴ': 'p i', 'ぷ': 'p M', 'ぺ': 'p e', 'ぽ': 'p o',
    'ぴゃ': 'p\' a', 'ぴゅ': 'p\' M', 'ぴょ': 'p\' o',
    // Small vowels (for combinations)
    'ぁ': 'a', 'ぃ': 'i', 'ぅ': 'M', 'ぇ': 'e', 'ぉ': 'o',
    // Small ya/yu/yo
    'ゃ': 'a', 'ゅ': 'M', 'ょ': 'o',
    // Long vowel
    'ー': '-',
    // Sokuon (double consonant marker - handled specially)
    'っ': 'cl',
  };

  // Katakana to Hiragana conversion (basic mapping)
  const katakanaToHiragana: Record<string, string> = {
    'ア': 'あ', 'イ': 'い', 'ウ': 'う', 'エ': 'え', 'オ': 'お',
    'カ': 'か', 'キ': 'き', 'ク': 'く', 'ケ': 'け', 'コ': 'こ',
    'サ': 'さ', 'シ': 'し', 'ス': 'す', 'セ': 'せ', 'ソ': 'そ',
    'タ': 'た', 'チ': 'ち', 'ツ': 'つ', 'テ': 'て', 'ト': 'と',
    'ナ': 'な', 'ニ': 'に', 'ヌ': 'ぬ', 'ネ': 'ね', 'ノ': 'の',
    'ハ': 'は', 'ヒ': 'ひ', 'フ': 'ふ', 'ヘ': 'へ', 'ホ': 'ほ',
    'マ': 'ま', 'ミ': 'み', 'ム': 'む', 'メ': 'め', 'モ': 'も',
    'ヤ': 'や', 'ユ': 'ゆ', 'ヨ': 'よ',
    'ラ': 'ら', 'リ': 'り', 'ル': 'る', 'レ': 'れ', 'ロ': 'ろ',
    'ワ': 'わ', 'ヲ': 'を', 'ン': 'ん',
    'ガ': 'が', 'ギ': 'ぎ', 'グ': 'ぐ', 'ゲ': 'げ', 'ゴ': 'ご',
    'ザ': 'ざ', 'ジ': 'じ', 'ズ': 'ず', 'ゼ': 'ぜ', 'ゾ': 'ぞ',
    'ダ': 'だ', 'ヂ': 'ぢ', 'ヅ': 'づ', 'デ': 'で', 'ド': 'ど',
    'バ': 'ば', 'ビ': 'び', 'ブ': 'ぶ', 'ベ': 'べ', 'ボ': 'ぼ',
    'パ': 'ぱ', 'ピ': 'ぴ', 'プ': 'ぷ', 'ペ': 'ぺ', 'ポ': 'ぽ',
    'ァ': 'ぁ', 'ィ': 'ぃ', 'ゥ': 'ぅ', 'ェ': 'ぇ', 'ォ': 'ぉ',
    'ャ': 'ゃ', 'ュ': 'ゅ', 'ョ': 'ょ',
    'ッ': 'っ', 'ー': 'ー',
  };

  // Convert katakana to hiragana
  let normalized = '';
  for (const char of lyric) {
    normalized += katakanaToHiragana[char] ?? char;
  }

  // Try to find phoneme for each character/combination
  const phonemes: string[] = [];
  let i = 0;
  while (i < normalized.length) {
    // Try two-character combination first (for ya/yu/yo combinations)
    if (i + 1 < normalized.length) {
      const twoChar = normalized.substring(i, i + 2);
      const twoCharPhoneme = hiraganaToPhoneme[twoChar];
      if (twoCharPhoneme) {
        phonemes.push(twoCharPhoneme);
        i += 2;
        continue;
      }
    }

    // Single character
    const char = normalized[i];
    const phoneme = hiraganaToPhoneme[char];
    if (phoneme) {
      phonemes.push(phoneme);
    } else if (/[a-zA-Z]/.test(char)) {
      // Pass through English letters as-is
      phonemes.push(char.toLowerCase());
    } else {
      // Default to 'a' for unknown characters
      phonemes.push('a');
    }
    i++;
  }

  return phonemes.join(' ');
}

function escapeXml(str: string): string {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
}
