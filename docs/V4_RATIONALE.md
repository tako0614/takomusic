# Tako v4 設計根拠と優先度分析

## 1. v3 で遭遇した実際の問題

### 1.1 cyberpunk_drive.mf 作成時の課題

```mf
// 問題1: アルペジオ生成の冗長性
// 理想: arp(majorTriad(C4), s, up, vel: 0.7)
// 現実: 10行以上のforループ
let c = clip {};
for (p in arpeggioUp(am)) {
  c = concat(c, clip { note(p, s, vel: 0.7); });
}
for (p in arpeggioDown(am)) {
  c = concat(c, clip { note(p, s, vel: 0.6); });
}
// これを4コード分繰り返す...

// 問題2: humanize の戻り値処理
const result = humanize(c, rng, 0.01, 0.05);
const newRng = result[0];  // タプル分解が欲しい
const humanized = result[1];

// 問題3: 関数チェーンの可読性
const final = transpose(
  quantize(
    swing(
      humanize(clip, rng, 0.01, 0.05)[1],
      e, 0.3
    ),
    s, 0.8
  ),
  12
);
// パイプラインなら: clip |> humanize(rng, ...) |> swing(e, 0.3) |> ...
```

### 1.2 theory.mf ライブラリの問題

```mf
// 問題: minorSeventh (interval) vs minor7 (chord) の混同
// 名前が紛らわしく、ユーザーが間違えやすい
chord(minorSeventh(A3), w);  // エラー: interval を渡している
chord(minor7(A3), w);        // 正解: chord 関数

// 根本原因: 型システムが Pitch と [Pitch] を十分区別できていない
// v4では IntervalFn と ChordFn を型レベルで区別
```

### 1.3 Parser/Evaluator のバグ

```mf
// 問題: ループ内の複合代入が失敗
for (i in 0..10) {
  s = (s * 1103515245 + 12345) % 2147483648;  // "Invalid assignment target"
}
// ワークアラウンド: インデックスベースの計算に書き換え

// 原因: パーサーが複雑な右辺式を持つ代入を正しく処理できない
// v4では代入文の構文解析を改善
```

## 2. ユーザー視点での優先度

### 高優先度（日常的に影響）

| 機能 | 理由 | v4 解決策 |
|------|------|-----------|
| パイプライン演算子 | 変換チェーンが読みにくい | `\|>` 演算子 |
| タプル分解 | RNG 関数の戻り値処理が冗長 | `const (a, b) = ...` |
| インラインアルペジオ | ループ記述が多すぎる | `arp()` ステートメント |
| テンプレートリテラル | 文字列連結が面倒 | `"${var}"` 構文 |

### 中優先度（特定ユースケースで影響）

| 機能 | 理由 | v4 解決策 |
|------|------|-----------|
| 連符サポート | 3連符の記述が手動計算 | `triplet { }` ブロック |
| グラデーショナルテンポ | rit./accel. が多数のポイント必要 | `over Xbars curve:` |
| スコア合成 | 複数セクションの結合 | `++` 演算子 |
| ジェネリクス | map/filter の型安全性 | `fn map<T, U>(...)` |

### 低優先度（高度なユースケース）

| 機能 | 理由 | v4 解決策 |
|------|------|-----------|
| マクロ | DSL 拡張 | `macro!` 構文 |
| ライブコーディング | パフォーマンス用途 | `#[live]` アノテーション |
| MIDI インポート | 既存データ活用 | `std:midi.importMidi()` |

## 3. 実装難易度分析

### 簡単（1-2週間）

- テンプレートリテラル（Lexer/Parser 変更のみ）
- スプレッド演算子（Evaluator 変更）
- インラインアルペジオ（シンタックスシュガー）
- 動的 PosRef（既存機能の拡張）

### 中程度（1-2ヶ月）

- パイプライン演算子（構文解析 + 型推論）
- タプル分解（パターンマッチング拡張）
- 連符ブロック（時間モデル変更）
- グラデーショナルテンポ（IR 変更 + Renderer 対応）

### 難しい（3ヶ月以上）

- ジェネリクス（型システム全面改修）
- 代数的データ型（型定義構文 + パターンマッチング）
- マクロシステム（衛生的マクロの設計）
- スコア合成（Sound ID 衝突解決 etc.）

## 4. 推奨実装順序

### Phase 0: 基盤整備（2週間）

1. テスト基盤強化（既存機能のリグレッション防止）
2. エラーメッセージ改善（デバッグ効率向上）
3. LSP 基本機能（開発体験向上）

### Phase 1: Quick Wins（1ヶ月）

1. **テンプレートリテラル** - 最小労力で大きな改善
2. **パイプライン演算子** - コード可読性の劇的改善
3. **インラインアルペジオ** - 音楽記述の簡素化
4. **スプレッド演算子** - 配列操作の簡素化

### Phase 2: 型システム基礎（2ヶ月）

1. **タプル型とタプル分解** - RNG 関数の UX 改善
2. **改善されたパターンマッチング** - 型ガード、範囲パターン
3. **型エイリアス** - ドメイン型の明確化

### Phase 3: 時間モデル（2ヶ月）

1. **連符ブロック** - 複雑なリズムの表現
2. **グラデーショナルテンポ** - 表現力向上
3. **アナクルーシス** - 古典音楽サポート
4. **IR Schema v4** - 上記機能のシリアライズ

### Phase 4: 高度な型システム（3ヶ月）

1. **ジェネリクス** - 標準ライブラリの型安全化
2. **代数的データ型** - ChordQuality 等の表現
3. **Result 型** - エラーハンドリング

### Phase 5: エコシステム（継続的）

1. **パッケージマネージャー** - 依存関係管理
2. **LSP 完全実装** - IDE 体験
3. **テストフレームワーク** - 品質保証
4. **ライブコーディング** - パフォーマンス用途

## 5. 破壊的変更の最小化

### 完全互換維持

- すべての v3 構文は v4 でも有効
- v3 の標準ライブラリ API は維持

### 非推奨（Deprecated）

```mf
// v3 スタイル（動作するが警告）
const result = humanize(c, r, 0.01, 0.05);
const newRng = result[0];
const newClip = result[1];

// v4 推奨スタイル
const (newRng, newClip) = humanize(c, r, 0.01, 0.05);
```

### 移行支援

```bash
# 自動移行ツール
tako migrate src/ --from v3 --to v4 --dry-run
tako migrate src/ --from v3 --to v4

# 互換モード
[compiler]
compatibility = "v3"  # v3 警告を抑制
```

## 6. コミュニティフィードバック収集計画

### v4 RFC プロセス

1. **RFC 0001: パイプライン演算子** - 構文案、優先度、結合性
2. **RFC 0002: 連符リテラル** - `triplet` vs `tuplet(3,2)` vs `3q`
3. **RFC 0003: スコア合成** - マージ戦略、衝突解決
4. **RFC 0004: ジェネリクス構文** - `fn<T>` vs `fn[T]` vs `@T`

### アルファリリース計画

```
v4.0.0-alpha.1 - パイプライン + テンプレートリテラル
v4.0.0-alpha.2 - タプル分解 + パターンマッチング
v4.0.0-alpha.3 - 連符 + グラデーショナルテンポ
v4.0.0-beta.1  - ジェネリクス（オプトイン）
v4.0.0-rc.1    - 全機能統合
v4.0.0         - 安定版リリース
```

## 7. 成功指標

### 定量指標

| 指標 | v3 現状 | v4 目標 |
|------|---------|---------|
| cyberpunk_drive.mf の行数 | 472行 | < 300行 |
| アルペジオ生成のコード量 | 10行/コード | 1行/コード |
| 変換チェーンの可読性 | ネスト深度5+ | ネスト深度1 |
| エラーメッセージの有用性 | 基本的 | Rust 並み |

### 定性指標

- 新規ユーザーが30分で最初の曲を作成可能
- 複雑な曲でも「自然に書ける」感覚
- エラーメッセージだけで問題を特定可能
- IDE 支援により補完だけでコード記述可能

## 8. 結論

v4 の核心は「**音楽を考えることに集中できる言語**」の実現である。

v3 では言語の制約（アルペジオのループ、RNG の戻り値処理等）が音楽的思考を妨げることがあった。v4 ではこれらの摩擦を取り除き、作曲者の意図をより直接的にコードに反映できるようにする。

最も重要な改善は:
1. **パイプライン演算子** - 変換の流れを自然に表現
2. **タプル分解** - 冗長なボイラープレート削減
3. **インラインアルペジオ** - 音楽パターンの直接表現
4. **連符サポート** - 複雑なリズムの自然な記述

これらは実装難易度が比較的低く、ユーザー体験への影響が大きいため、Phase 1 で優先的に実装すべきである。
