// MFS Standard Library - Ornaments
// These are ornament functions written in the MFS language itself

// trill: Alternates rapidly between main pitch and upper pitch
// pitch: the main pitch
// dur: total duration
// interval: semitones to upper note (default 2 = whole step)
export proc trill(pitch, dur, interval) {
  let ppq = getPpq();
  let durTicks = durToTicks(dur);
  let startTick = cursor();
  let trillNoteDur = floor(ppq / 8);
  if (trillNoteDur < 1) {
    trillNoteDur = 1;
  }
  let upperPitch = transpose(pitch, interval);
  let vel = getVel();

  let currentTick = startTick;
  let isUpper = false;

  while (currentTick < startTick + durTicks) {
    let noteDur = trillNoteDur;
    if (noteDur > startTick + durTicks - currentTick) {
      noteDur = startTick + durTicks - currentTick;
    }
    if (isUpper) {
      noteAt(currentTick, upperPitch, noteDur, vel);
    } else {
      noteAt(currentTick, pitch, noteDur, vel);
    }
    currentTick += trillNoteDur;
    isUpper = !isUpper;
  }

  advanceTick(durTicks);
}

// mordent: Quick ornament - main note, auxiliary, back to main
// pitch: the main pitch
// dur: total duration
// upper: if true, go up 2 semitones; if false, go down 2 semitones
export proc mordent(pitch, dur, upper) {
  let ppq = getPpq();
  let durTicks = durToTicks(dur);
  let startTick = cursor();
  let ornamentDur = floor(ppq / 8);
  if (ornamentDur < 1) {
    ornamentDur = 1;
  }
  let auxInterval = 2;
  if (!upper) {
    auxInterval = -2;
  }
  let auxPitch = transpose(pitch, auxInterval);
  let vel = getVel();

  // First note: main pitch
  noteAt(startTick, pitch, ornamentDur, vel);
  // Second note: auxiliary pitch
  noteAt(startTick + ornamentDur, auxPitch, ornamentDur, vel);
  // Third note: main pitch for remaining duration
  let remainingDur = durTicks - ornamentDur * 2;
  if (remainingDur > 0) {
    noteAt(startTick + ornamentDur * 2, pitch, remainingDur, vel);
  }

  advanceTick(durTicks);
}

// arpeggio: Plays chord notes in sequence with overlap
// pitches: array of pitches
// dur: total duration
// spread: tick offset between notes
export proc arpeggio(pitches, dur, spread) {
  let durTicks = durToTicks(dur);
  let startTick = cursor();
  let vel = getVel();

  for (i in 0..len(pitches)) {
    let p = pitches[i];
    let noteTick = startTick + i * spread;
    let noteDur = durTicks - i * spread;
    if (noteDur > 0) {
      noteAt(noteTick, p, noteDur, vel);
    }
  }

  advanceTick(durTicks);
}

// glissando: Chromatic slide between two pitches
// startPitch: starting pitch
// endPitch: ending pitch
// dur: total duration
export proc glissando(startPitch, endPitch, dur) {
  let durTicks = durToTicks(dur);
  let startTick = cursor();
  let vel = getVel();

  let startMidi = pitchMidi(startPitch);
  let endMidi = pitchMidi(endPitch);
  let direction = 1;
  if (endMidi < startMidi) {
    direction = -1;
  }
  let numNotes = abs(endMidi - startMidi) + 1;
  let noteDur = floor(durTicks / numNotes);
  if (noteDur < 1) {
    noteDur = 1;
  }

  for (i in 0..numNotes) {
    let midiNote = startMidi + i * direction;
    let tick = startTick + i * noteDur;
    if (tick < startTick + durTicks) {
      noteAt(tick, midiPitch(midiNote), noteDur, vel);
    }
  }

  advanceTick(durTicks);
}

// tremolo: Rapidly repeating the same note
// pitch: the pitch to repeat
// dur: total duration
// speed: divisions per whole note (32 = 32nd notes)
export proc tremolo(pitch, dur, speed) {
  let ppq = getPpq();
  let durTicks = durToTicks(dur);
  let startTick = cursor();
  let noteDur = floor((ppq * 4) / speed);
  if (noteDur < 1) {
    noteDur = 1;
  }
  let vel = getVel();

  let currentTick = startTick;
  while (currentTick < startTick + durTicks) {
    let actualDur = noteDur;
    if (actualDur > startTick + durTicks - currentTick) {
      actualDur = startTick + durTicks - currentTick;
    }
    noteAt(currentTick, pitch, actualDur, vel);
    currentTick += noteDur;
  }

  advanceTick(durTicks);
}
