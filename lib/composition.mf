// Composition techniques for TakoMusic
// Melodic and structural transformations

import { clip } from "./utils.mf";

// Melodic sequence - transpose pattern by intervals
export proc sequence(melody, intervals, dur) {
  // Play original
  for (i in 0..len(melody)) {
    note(melody[i], dur);
  }

  // Play transposed versions
  for (j in 0..len(intervals)) {
    for (i in 0..len(melody)) {
      note(transpose(melody[i], intervals[j]), dur);
    }
  }
}

// Sequence with individual durations
export proc sequenceWithDurs(melody, durs, intervals) {
  // Play original
  for (i in 0..len(melody)) {
    note(melody[i], durs[i]);
  }

  // Play transposed versions
  for (j in 0..len(intervals)) {
    for (i in 0..len(melody)) {
      note(transpose(melody[i], intervals[j]), durs[i]);
    }
  }
}

// Call and response pattern
export proc callResponse(call, response, callDur, responseDur, gap) {
  // Call
  for (i in 0..len(call)) {
    note(call[i], callDur);
  }

  // Gap
  rest(gap);

  // Response
  for (i in 0..len(response)) {
    note(response[i], responseDur);
  }
}

// Call and response with automatic response generation (echo)
export proc callEcho(call, callDur, interval, gap) {
  // Call
  for (i in 0..len(call)) {
    note(call[i], callDur);
  }

  // Gap
  rest(gap);

  // Echo (transposed and softer)
  for (i in 0..len(call)) {
    note(transpose(call[i], interval), callDur, 70);
  }
}

// Ostinato - repeating pattern
export proc ostinato(pattern, dur, repetitions) {
  for (rep in 0..repetitions) {
    for (i in 0..len(pattern)) {
      note(pattern[i], dur);
    }
  }
}

// Ostinato with individual durations
export proc ostinatoWithDurs(pattern, durs, repetitions) {
  for (rep in 0..repetitions) {
    for (i in 0..len(pattern)) {
      note(pattern[i], durs[i]);
    }
  }
}

// Canon - same melody with delayed entries
// Returns the total duration for synchronization
export proc canonMelody(melody, dur, delayBeats) {
  for (i in 0..len(melody)) {
    note(melody[i], dur);
  }
  return len(melody) * dur;
}

// Helper to create canon entry point
export proc canonEntry(melody, dur, entryNumber, delayBeats) {
  // Wait for entry
  rest(delayBeats * entryNumber);

  // Play melody
  for (i in 0..len(melody)) {
    note(melody[i], dur);
  }
}

// Imitation - similar to canon but with transformation
export proc imitation(melody, dur, interval, invert) {
  for (i in 0..len(melody)) {
    let pitch = melody[i];

    if (invert) {
      // Invert around first note
      const axis = melody[0];
      const axisMidi = pitchMidi(axis);
      const noteMidi = pitchMidi(pitch);
      const inverted = axisMidi - (noteMidi - axisMidi);
      pitch = midiPitch(clip(inverted, 0, 127));
    }

    note(transpose(pitch, interval), dur);
  }
}

// Theme and variation - apply transformation to theme
export proc variation(theme, dur, variationType) {
  if (variationType == "original") {
    for (i in 0..len(theme)) {
      note(theme[i], dur);
    }
  }

  if (variationType == "octave") {
    for (i in 0..len(theme)) {
      note(transpose(theme[i], 12), dur);
    }
  }

  if (variationType == "retrograde") {
    for (i in 0..len(theme)) {
      const idx = len(theme) - 1 - i;
      note(theme[idx], dur);
    }
  }

  if (variationType == "augment") {
    for (i in 0..len(theme)) {
      note(theme[i], dur * 2);
    }
  }

  if (variationType == "diminish") {
    for (i in 0..len(theme)) {
      note(theme[i], dur / 2);
    }
  }

  if (variationType == "invert") {
    const axis = theme[0];
    const axisMidi = pitchMidi(axis);

    for (i in 0..len(theme)) {
      const noteMidi = pitchMidi(theme[i]);
      const inverted = axisMidi - (noteMidi - axisMidi);
      note(midiPitch(clip(inverted, 0, 127)), dur);
    }
  }
}

// Hocket - alternating notes between voices (returns patterns)
export proc hocket(melody) {
  let voice1 = [];
  let voice2 = [];

  for (i in 0..len(melody)) {
    if (i % 2 == 0) {
      push(voice1, melody[i]);
      push(voice2, 0);  // 0 = rest
    } else {
      push(voice1, 0);
      push(voice2, melody[i]);
    }
  }

  return [voice1, voice2];
}

// Play hocket pattern (0 = rest)
export proc playHocket(pattern, dur) {
  for (i in 0..len(pattern)) {
    if (pattern[i] == 0) {
      rest(dur);
    } else {
      note(pattern[i], dur);
    }
  }
}

// Stretto - overlapping entries
export proc strettoEntry(melody, dur, entryOffset) {
  rest(entryOffset);
  for (i in 0..len(melody)) {
    note(melody[i], dur);
  }
}

// Pedal point - sustained bass note under changing harmony
export proc pedalPoint(pitch, dur, repetitions) {
  for (i in 0..repetitions) {
    note(pitch, dur);
  }
}

// Drone - continuous sustained notes
export proc drone(pitches, dur) {
  chord(pitches, dur);
}

// Arpeggio patterns for accompaniment
export proc albertiPattern(chordPitches, dur, repetitions) {
  const pattern = [0, 2, 1, 2];  // Alberti bass pattern

  for (rep in 0..repetitions) {
    for (i in 0..len(pattern)) {
      const idx = pattern[i];
      if (idx < len(chordPitches)) {
        note(chordPitches[idx], dur);
      }
    }
  }
}

// Broken chord ascending
export proc brokenChordUp(chordPitches, dur) {
  for (i in 0..len(chordPitches)) {
    note(chordPitches[i], dur);
  }
}

// Broken chord descending
export proc brokenChordDown(chordPitches, dur) {
  for (i in 0..len(chordPitches)) {
    const idx = len(chordPitches) - 1 - i;
    note(chordPitches[idx], dur);
  }
}

// Antiphonal - alternating between two groups
export proc antiphonal(group1, group2, dur, exchanges) {
  for (ex in 0..exchanges) {
    // Group 1
    for (i in 0..len(group1)) {
      note(group1[i], dur);
    }

    // Group 2
    for (i in 0..len(group2)) {
      note(group2[i], dur);
    }
  }
}

// Motivic development - fragment and develop
export proc motifFragment(melody, startIdx, endIdx, dur) {
  for (i in startIdx..endIdx) {
    if (i < len(melody)) {
      note(melody[i], dur);
    }
  }
}

// Extend motif by repetition with variation
export proc motifExtend(motif, dur, extensions) {
  // Original
  for (i in 0..len(motif)) {
    note(motif[i], dur);
  }

  // Extended with last note repeated
  for (ext in 0..extensions) {
    note(motif[len(motif) - 1], dur);
  }
}

// Rhythmic displacement - shift pattern by offset
export proc displace(melody, dur, offsetDur) {
  rest(offsetDur);
  for (i in 0..len(melody)) {
    note(melody[i], dur);
  }
}

// Polymelody helper - returns starting position
export proc layerMelody(melody, dur, startOffset) {
  rest(startOffset);
  for (i in 0..len(melody)) {
    note(melody[i], dur);
  }
  return startOffset + len(melody) * dur;
}
