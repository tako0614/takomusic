// Notation helpers for TakoMusic
// Musical notation utilities and conversions

import { clip } from "./utils.mf";

// Convert dynamic marking to velocity
export proc dynamicToVel(marking) {
  if (marking == "pppp") { return 16; }
  if (marking == "ppp") { return 33; }
  if (marking == "pp") { return 49; }
  if (marking == "p") { return 64; }
  if (marking == "mp") { return 80; }
  if (marking == "mf") { return 96; }
  if (marking == "f") { return 112; }
  if (marking == "ff") { return 120; }
  if (marking == "fff") { return 124; }
  if (marking == "ffff") { return 127; }
  return 96; // default mf
}

// Convert tempo marking to BPM
export proc tempoToBpm(marking) {
  if (marking == "grave") { return 40; }
  if (marking == "largo") { return 50; }
  if (marking == "lento") { return 60; }
  if (marking == "adagio") { return 70; }
  if (marking == "andante") { return 90; }
  if (marking == "moderato") { return 110; }
  if (marking == "allegretto") { return 115; }
  if (marking == "allegro") { return 130; }
  if (marking == "vivace") { return 150; }
  if (marking == "presto") { return 180; }
  if (marking == "prestissimo") { return 200; }
  return 120; // default
}

// Play triplet feel
export proc tripletFeel(notes, baseDur) {
  const longDur = baseDur * 2/3;
  const shortDur = baseDur * 1/3;

  for (i in 0..len(notes)) {
    if (i % 2 == 0) {
      note(notes[i], longDur);
    } else {
      note(notes[i], shortDur);
    }
  }
}

// Play dotted rhythm
export proc dottedRhythm(notes, baseDur) {
  const longDur = baseDur * 3/4;
  const shortDur = baseDur * 1/4;

  for (i in 0..len(notes)) {
    if (i % 2 == 0) {
      note(notes[i], longDur);
    } else {
      note(notes[i], shortDur);
    }
  }
}

// Generate scale in specific octave range
export proc scaleInRange(scaleFunc, root, octaves) {
  let result = [];
  for (oct in 0..octaves) {
    const octaveRoot = transpose(root, oct * 12);
    const scale = scaleFunc(octaveRoot);
    for (i in 0..len(scale) - 1) {
      push(result, scale[i]);
    }
  }
  return result;
}

// Create melody from scale degrees
export proc melodyFromDegrees(scale, degrees, dur) {
  for (i in 0..len(degrees)) {
    const degree = degrees[i];
    if (degree == 0) {
      rest(dur);
    } else {
      const idx = (degree - 1) % len(scale);
      const octave = floor((degree - 1) / len(scale));
      const pitch = transpose(scale[idx], octave * 12);
      note(pitch, dur);
    }
  }
}

// Harmonize melody with interval
export proc harmonize(melody, interval, dur) {
  for (i in 0..len(melody)) {
    const pitches = [melody[i], transpose(melody[i], interval)];
    chord(pitches, dur);
  }
}

// Create countermelody (simple inversion)
export proc invertMelody(melody, axis) {
  let result = [];
  const axisMidi = pitchMidi(axis);

  for (i in 0..len(melody)) {
    const pitchMidi = pitchMidi(melody[i]);
    const distance = pitchMidi - axisMidi;
    const inverted = axisMidi - distance;
    push(result, midiPitch(clip(inverted, 0, 127)));
  }

  return result;
}

// Retrograde (reverse) melody
export proc retrograde(melody) {
  let result = [];
  for (i in 0..len(melody)) {
    const idx = len(melody) - 1 - i;
    push(result, melody[idx]);
  }
  return result;
}

// Rhythmic augmentation (make durations longer)
export proc augment(rhythms, factor) {
  let result = [];
  for (i in 0..len(rhythms)) {
    push(result, rhythms[i] * factor);
  }
  return result;
}

// Rhythmic diminution (make durations shorter)
export proc diminish(rhythms, factor) {
  return augment(rhythms, 1 / factor);
}

// Generate pickup notes (anacrusis)
export proc pickupNotes(notes, totalDur, noteDur) {
  const pickupDur = len(notes) * noteDur;
  const waitDur = totalDur - pickupDur;

  if (waitDur > 0) {
    rest(waitDur);
  }

  for (i in 0..len(notes)) {
    note(notes[i], noteDur);
  }
}

// Bass line from chord progression
export proc bassLine(chords, dur) {
  for (i in 0..len(chords)) {
    const root = chords[i][0];
    const bassNote = transpose(root, -12);
    note(bassNote, dur);
  }
}

// Walking bass pattern
export proc walkingBass(chord, nextChord, dur) {
  const root = chord[0];
  const third = chord[1];
  const fifth = chord[2];
  const nextRoot = nextChord[0];

  // Basic walking pattern: root, third, fifth, approach
  note(transpose(root, -12), dur);
  note(transpose(third, -12), dur);
  note(transpose(fifth, -12), dur);

  // Approach note (half step below next root)
  const approach = transpose(nextRoot, -13);
  note(approach, dur);
}

// Alberti bass pattern
export proc albertiBass(chord, repetitions, dur) {
  const pattern = [0, 2, 1, 2]; // root, fifth, third, fifth

  for (rep in 0..repetitions) {
    for (i in 0..len(pattern)) {
      const idx = pattern[i];
      if (idx < len(chord)) {
        note(transpose(chord[idx], -12), dur);
      }
    }
  }
}

// Convert note name to pitch
export proc noteNameToPitch(name, octave) {
  let semitone = 0;

  const noteLetter = charAt(name, 0);
  if (noteLetter == "C") { semitone = 0; }
  if (noteLetter == "D") { semitone = 2; }
  if (noteLetter == "E") { semitone = 4; }
  if (noteLetter == "F") { semitone = 5; }
  if (noteLetter == "G") { semitone = 7; }
  if (noteLetter == "A") { semitone = 9; }
  if (noteLetter == "B") { semitone = 11; }

  // Check for accidental
  if (len(name) > 1) {
    const accidental = charAt(name, 1);
    if (accidental == "#") { semitone = semitone + 1; }
    if (accidental == "b") { semitone = semitone - 1; }
  }

  const midiNum = 12 + octave * 12 + semitone;
  return midiPitch(clip(midiNum, 0, 127));
}

// Tuplet helper (generic n-tuplet)
export proc playTuplet(notes, totalDur, ratio) {
  const noteDur = totalDur / len(notes) * ratio;
  for (i in 0..len(notes)) {
    note(notes[i], noteDur);
  }
}
