// Advanced pattern generation for TakoMusic
// Algorithmic composition and generative music

import { choice, shuffle, clip, wrap, rotate } from "./utils.mf";

// Random walk melody generator
export proc randomWalk(startPitch, steps, maxStep) {
  let melody = [];
  let current = startPitch;

  for (i in 0..steps) {
    push(melody, current);
    const step = random(-maxStep, maxStep + 1);
    current = transpose(current, step);
    current = transpose(C0, clip(pitchMidi(current), 0, 127));
  }

  return melody;
}

// Pentatonic random walk
export proc pentatonicWalk(root, steps) {
  const scale = [0, 2, 4, 7, 9, 12];
  let melody = [];
  let idx = 0;

  for (i in 0..steps) {
    const offset = scale[idx % len(scale)];
    const octave = floor(idx / len(scale));
    push(melody, transpose(root, offset + octave * 12));

    const step = random(-2, 3);
    idx = clip(idx + step, 0, len(scale) * 3 - 1);
  }

  return melody;
}

// Fractal melody generator (simple self-similarity)
export proc fractalMelody(pattern, depth) {
  if (depth == 0) {
    return pattern;
  }

  let result = [];
  for (i in 0..len(pattern)) {
    const pitch = pattern[i];
    push(result, pitch);

    // Insert transposed version of pattern at smaller scale
    const subPattern = fractalMelody(pattern, depth - 1);
    for (j in 0..len(subPattern)) {
      push(result, transpose(subPattern[j], 7));
    }
  }

  return result;
}

// Probability-based rhythm pattern
export proc probabilityRhythm(steps, probability) {
  let pattern = [];
  for (i in 0..steps) {
    push(pattern, random() < probability);
  }
  return pattern;
}

// Density-based rhythm (gradually increase/decrease density)
export proc densityRhythm(steps, startProb, endProb) {
  let pattern = [];
  for (i in 0..steps) {
    const t = i / (steps - 1);
    const prob = startProb + (endProb - startProb) * t;
    push(pattern, random() < prob);
  }
  return pattern;
}

// Polyrhythmic pattern generator
export proc polyrhythm(ratio1, ratio2, cycles) {
  const totalSteps = ratio1 * ratio2;
  let pattern1 = [];
  let pattern2 = [];

  for (i in 0..totalSteps * cycles) {
    push(pattern1, i % ratio1 == 0);
    push(pattern2, i % ratio2 == 0);
  }

  return [pattern1, pattern2];
}

// Phasing pattern (Steve Reich style)
export proc phasePattern(pattern, phaseShift, repetitions) {
  let result = [];

  for (rep in 0..repetitions) {
    const shift = floor(rep * phaseShift) % len(pattern);
    const rotated = rotate(pattern, shift);
    for (i in 0..len(rotated)) {
      push(result, rotated[i]);
    }
  }

  return result;
}

// Markov chain melody (simple 2-state)
export proc markovMelody(notes, transitionProb, length, startIdx) {
  let melody = [];
  let currentIdx = startIdx;

  for (i in 0..length) {
    push(melody, notes[currentIdx]);

    // Simple transition: stay or move
    if (random() < transitionProb) {
      currentIdx = (currentIdx + 1) % len(notes);
    }
  }

  return melody;
}

// Arpeggiate chord with pattern
export proc arpeggiate(chord, pattern, dur) {
  for (i in 0..len(pattern)) {
    const idx = pattern[i];
    if (idx >= 0 && idx < len(chord)) {
      note(chord[idx], dur);
    } else {
      rest(dur);
    }
  }
}

// Generate arpeggio pattern (up, down, up-down, random)
export proc arpeggioPattern(chordSize, style, length) {
  let pattern = [];

  for (i in 0..length) {
    let idx = 0;

    if (style == "up") {
      idx = i % chordSize;
    } else {
      if (style == "down") {
        idx = chordSize - 1 - (i % chordSize);
      } else {
        if (style == "updown") {
          const cycle = chordSize * 2 - 2;
          const pos = i % cycle;
          if (pos < chordSize) {
            idx = pos;
          } else {
            idx = chordSize - 2 - (pos - chordSize);
          }
        } else {
          // random
          idx = random(chordSize);
        }
      }
    }

    push(pattern, idx);
  }

  return pattern;
}
