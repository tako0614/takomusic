// std:core (v3)

fn posToRat(pos) {
  if (pos == null) {
    return null;
  }
  if (pos.kind == "rat") {
    return pos.rat;
  }
  if (pos.kind != null) {
    return null;
  }
  if (pos.n != null && pos.d != null) {
    return pos;
  }
  return null;
}

fn eventStartRat(ev) {
  if (ev.type == "marker") {
    return posToRat(ev.pos);
  }
  if (ev.type == "automation") {
    return posToRat(ev.start);
  }
  return posToRat(ev.start);
}

fn eventEndRat(ev) {
  if (ev.type == "note" || ev.type == "chord" || ev.type == "drumHit" || ev.type == "breath") {
    const start = posToRat(ev.start);
    if (start == null) {
      return null;
    }
    return start + ev.dur;
  }
  if (ev.type == "control") {
    return posToRat(ev.start);
  }
  if (ev.type == "automation") {
    return posToRat(ev.end);
  }
  if (ev.type == "marker") {
    return posToRat(ev.pos);
  }
  return null;
}

fn clipLength(c) {
  if (c.length != null) {
    return c.length;
  }
  let max = null;
  for (ev in c.events) {
    const end = eventEndRat(ev);
    if (end == null) {
      return null;
    }
    if (max == null || end > max) {
      max = end;
    }
  }
  if (max == null) {
    return 0 / 1;
  }
  return max;
}

fn shiftPos(pos, offset) {
  if (pos == null) {
    return pos;
  }
  return pos + offset;
}

fn shiftEvent(ev, offset) {
  if (ev.type == "note") {
    return {
      type: "note",
      start: shiftPos(ev.start, offset),
      dur: ev.dur,
      pitch: ev.pitch,
      velocity: ev.velocity,
      voice: ev.voice,
      techniques: ev.techniques,
      lyric: ev.lyric,
      ext: ev.ext
    };
  }
  if (ev.type == "chord") {
    return {
      type: "chord",
      start: shiftPos(ev.start, offset),
      dur: ev.dur,
      pitches: ev.pitches,
      velocity: ev.velocity,
      voice: ev.voice,
      techniques: ev.techniques,
      ext: ev.ext
    };
  }
  if (ev.type == "drumHit") {
    return {
      type: "drumHit",
      start: shiftPos(ev.start, offset),
      dur: ev.dur,
      key: ev.key,
      velocity: ev.velocity,
      techniques: ev.techniques,
      ext: ev.ext
    };
  }
  if (ev.type == "control") {
    return {
      type: "control",
      start: shiftPos(ev.start, offset),
      kind: ev.kind,
      data: ev.data,
      ext: ev.ext
    };
  }
  if (ev.type == "automation") {
    return {
      type: "automation",
      param: ev.param,
      start: shiftPos(ev.start, offset),
      end: shiftPos(ev.end, offset),
      curve: ev.curve,
      ext: ev.ext
    };
  }
  if (ev.type == "marker") {
    return {
      type: "marker",
      pos: shiftPos(ev.pos, offset),
      kind: ev.kind,
      label: ev.label
    };
  }
  if (ev.type == "breath") {
    return {
      type: "breath",
      start: shiftPos(ev.start, offset),
      dur: ev.dur,
      intensity: ev.intensity,
      ext: ev.ext
    };
  }
  return ev;
}

export fn concat(a, b) {
  const offset = clipLength(a);
  const zero = 0 / 1;
  let events = [];
  for (ev in a.events) {
    events[events.length] = shiftEvent(ev, zero);
  }
  for (ev in b.events) {
    events[events.length] = shiftEvent(ev, offset);
  }
  const length = clipLength({ events: events });
  return { events: events, length: length };
}

export fn overlay(a, b) {
  const zero = 0 / 1;
  let events = [];
  for (ev in a.events) {
    events[events.length] = shiftEvent(ev, zero);
  }
  for (ev in b.events) {
    events[events.length] = shiftEvent(ev, zero);
  }
  let length = null;
  if (a.length != null && b.length != null) {
    length = a.length;
    if (b.length > a.length) {
      length = b.length;
    }
  } else if (a.length != null) {
    length = a.length;
  } else if (b.length != null) {
    length = b.length;
  } else {
    length = clipLength({ events: events });
  }
  return { events: events, length: length };
}

export fn repeat(c, count) {
  if (count <= 0) {
    return { events: [], length: 0 / 1 };
  }
  const len = clipLength(c);
  let events = [];
  for (i in 0..(count - 1)) {
    const offset = len * i;
    for (ev in c.events) {
      events[events.length] = shiftEvent(ev, offset);
    }
  }
  return { events: events, length: len * count };
}

export fn slice(c, startPos, endPos) {
  const start = posToRat(startPos);
  const end = posToRat(endPos);
  let events = [];
  for (ev in c.events) {
    const pos = eventStartRat(ev);
    if (pos == null) {
      continue;
    }
    // Range is [start, end) - end is exclusive per STDLIB.md
    if (pos < start || pos >= end) {
      continue;
    }
    events[events.length] = shiftEvent(ev, 0 / 1 - start);
  }
  return { events: events, length: end - start };
}

export fn mapEvents(c, f) {
  let events = [];
  for (ev in c.events) {
    const mapped = f(ev);
    if (mapped != null) {
      events[events.length] = mapped;
    }
  }
  const length = clipLength({ events: events });
  return { events: events, length: length };
}

fn copyTracks(tracks) {
  let out = [];
  for (trk in tracks) {
    out[out.length] = trk;
  }
  return out;
}

export fn withTrack(sc, trk) {
  const tracks = copyTracks(sc.tracks);
  tracks[tracks.length] = trk;
  return {
    meta: sc.meta,
    tempoMap: sc.tempoMap,
    meterMap: sc.meterMap,
    sounds: sc.sounds,
    tracks: tracks,
    markers: sc.markers
  };
}

export fn mapTracks(sc, f) {
  let tracks = [];
  for (trk in sc.tracks) {
    tracks[tracks.length] = f(trk);
  }
  return {
    meta: sc.meta,
    tempoMap: sc.tempoMap,
    meterMap: sc.meterMap,
    sounds: sc.sounds,
    tracks: tracks,
    markers: sc.markers
  };
}

// getTracks - extract all tracks from a score
export fn getTracks(sc) {
  if (sc == null) {
    return [];
  }
  if (sc.tracks != null) {
    return sc.tracks;
  }
  return [];
}

// shift - shift all event positions by offset
export fn shift(c, offset) {
  let events = [];
  for (ev in c.events) {
    events[events.length] = shiftEvent(ev, offset);
  }
  let length = null;
  if (c.length != null) {
    length = c.length;
  }
  return { events: events, length: length };
}

// padTo - extend clip length to at least endPos
export fn padTo(c, endPos) {
  const currentLen = clipLength(c);
  const target = posToRat(endPos);
  let newLength = currentLen;
  if (target != null && (currentLen == null || target > currentLen)) {
    newLength = target;
  }
  return { events: c.events, length: newLength };
}

// updateEvent - create modified copy of event with updated fields
// Usage: updateEvent(event, { start: newStart, dur: newDur, velocity: 0.8, ... })
fn getOrDefault(newVal, oldVal) {
  if (newVal != null) {
    return newVal;
  }
  return oldVal;
}

export fn updateEvent(ev, upd) {
  if (ev.type == "note") {
    return {
      type: "note",
      start: getOrDefault(upd.start, ev.start),
      dur: getOrDefault(upd.dur, ev.dur),
      pitch: getOrDefault(upd.pitch, ev.pitch),
      velocity: getOrDefault(upd.velocity, ev.velocity),
      voice: getOrDefault(upd.voice, ev.voice),
      techniques: getOrDefault(upd.techniques, ev.techniques),
      lyric: getOrDefault(upd.lyric, ev.lyric),
      ext: ev.ext
    };
  }
  if (ev.type == "chord") {
    return {
      type: "chord",
      start: getOrDefault(upd.start, ev.start),
      dur: getOrDefault(upd.dur, ev.dur),
      pitches: getOrDefault(upd.pitches, ev.pitches),
      velocity: getOrDefault(upd.velocity, ev.velocity),
      voice: getOrDefault(upd.voice, ev.voice),
      techniques: getOrDefault(upd.techniques, ev.techniques),
      ext: ev.ext
    };
  }
  if (ev.type == "drumHit") {
    return {
      type: "drumHit",
      start: getOrDefault(upd.start, ev.start),
      dur: getOrDefault(upd.dur, ev.dur),
      key: getOrDefault(upd.key, ev.key),
      velocity: getOrDefault(upd.velocity, ev.velocity),
      techniques: getOrDefault(upd.techniques, ev.techniques),
      ext: ev.ext
    };
  }
  if (ev.type == "breath") {
    return {
      type: "breath",
      start: getOrDefault(upd.start, ev.start),
      dur: getOrDefault(upd.dur, ev.dur),
      intensity: getOrDefault(upd.intensity, ev.intensity),
      ext: ev.ext
    };
  }
  if (ev.type == "control") {
    return {
      type: "control",
      start: getOrDefault(upd.start, ev.start),
      kind: getOrDefault(upd.kind, ev.kind),
      data: getOrDefault(upd.data, ev.data),
      ext: ev.ext
    };
  }
  if (ev.type == "automation") {
    return {
      type: "automation",
      param: getOrDefault(upd.param, ev.param),
      start: getOrDefault(upd.start, ev.start),
      end: getOrDefault(upd.end, ev.end),
      curve: getOrDefault(upd.curve, ev.curve),
      ext: ev.ext
    };
  }
  if (ev.type == "marker") {
    return {
      type: "marker",
      pos: getOrDefault(upd.start, ev.pos),
      kind: getOrDefault(upd.kind, ev.kind),
      label: getOrDefault(upd.label, ev.label)
    };
  }
  return ev;
}

// Utility functions

export fn max(a, b) {
  if (a > b) {
    return a;
  }
  return b;
}

export fn min(a, b) {
  if (a < b) {
    return a;
  }
  return b;
}

export fn abs(a) {
  if (a < 0) {
    return 0 - a;
  }
  return a;
}

fn floorNum(value) {
  return value - (value % 1);
}

export fn floor(a) {
  if (a.n != null && a.d != null) {
    const num = a.n / a.d;
    return floorNum(num);
  }
  return floorNum(a);
}

export fn ceil(a) {
  const f = floor(a);
  if (a.n != null && a.d != null) {
    const num = a.n / a.d;
    if (num > f) {
      return f + 1;
    }
    return f;
  }
  if (a > f) {
    return f + 1;
  }
  return f;
}

// length - returns the length of a clip
export fn length(c) {
  return clipLength(c);
}
