// std:core (v4)

fn posToRat(pos) {
  if (pos == null) {
    return null;
  }
  if (pos.kind == "rat") {
    return pos.rat;
  }
  if (pos.kind != null) {
    return null;
  }
  if (pos.n != null && pos.d != null) {
    return pos;
  }
  return null;
}

fn eventStartRat(ev) {
  if (ev.type == "marker") {
    return posToRat(ev.pos);
  }
  if (ev.type == "automation") {
    return posToRat(ev.start);
  }
  return posToRat(ev.start);
}

fn eventEndRat(ev) {
  if (ev.type == "note" || ev.type == "chord" || ev.type == "drumHit" || ev.type == "breath") {
    const start = posToRat(ev.start);
    if (start == null) {
      return null;
    }
    return start + ev.dur;
  }
  if (ev.type == "control") {
    return posToRat(ev.start);
  }
  if (ev.type == "automation") {
    return posToRat(ev.end);
  }
  if (ev.type == "marker") {
    return posToRat(ev.pos);
  }
  return null;
}

fn clipLength(c) {
  if (c.length != null) {
    return c.length;
  }
  let max = null;
  for (ev in c.events) {
    const end = eventEndRat(ev);
    if (end == null) {
      return null;
    }
    if (max == null || end > max) {
      max = end;
    }
  }
  if (max == null) {
    return 0 / 1;
  }
  return max;
}

fn shiftPos(pos, offset) {
  if (pos == null) {
    return pos;
  }
  return pos + offset;
}

fn shiftEvent(ev, offset) {
  if (ev.type == "note") {
    return {
      type: "note",
      start: shiftPos(ev.start, offset),
      dur: ev.dur,
      pitch: ev.pitch,
      velocity: ev.velocity,
      voice: ev.voice,
      techniques: ev.techniques,
      lyric: ev.lyric,
      ext: ev.ext
    };
  }
  if (ev.type == "chord") {
    return {
      type: "chord",
      start: shiftPos(ev.start, offset),
      dur: ev.dur,
      pitches: ev.pitches,
      velocity: ev.velocity,
      voice: ev.voice,
      techniques: ev.techniques,
      ext: ev.ext
    };
  }
  if (ev.type == "drumHit") {
    return {
      type: "drumHit",
      start: shiftPos(ev.start, offset),
      dur: ev.dur,
      key: ev.key,
      velocity: ev.velocity,
      techniques: ev.techniques,
      ext: ev.ext
    };
  }
  if (ev.type == "control") {
    return {
      type: "control",
      start: shiftPos(ev.start, offset),
      kind: ev.kind,
      data: ev.data,
      ext: ev.ext
    };
  }
  if (ev.type == "automation") {
    return {
      type: "automation",
      param: ev.param,
      start: shiftPos(ev.start, offset),
      end: shiftPos(ev.end, offset),
      curve: ev.curve,
      ext: ev.ext
    };
  }
  if (ev.type == "marker") {
    return {
      type: "marker",
      pos: shiftPos(ev.pos, offset),
      kind: ev.kind,
      label: ev.label
    };
  }
  if (ev.type == "breath") {
    return {
      type: "breath",
      start: shiftPos(ev.start, offset),
      dur: ev.dur,
      intensity: ev.intensity,
      ext: ev.ext
    };
  }
  return ev;
}

export fn concat(a, b) {
  const offset = clipLength(a);
  const zero = 0 / 1;
  let events = [];
  for (ev in a.events) {
    events[events.length] = shiftEvent(ev, zero);
  }
  for (ev in b.events) {
    events[events.length] = shiftEvent(ev, offset);
  }
  const length = clipLength({ events: events });
  return { events: events, length: length };
}

export fn overlay(a, b) {
  const zero = 0 / 1;
  let events = [];
  for (ev in a.events) {
    events[events.length] = shiftEvent(ev, zero);
  }
  for (ev in b.events) {
    events[events.length] = shiftEvent(ev, zero);
  }
  let length = null;
  if (a.length != null && b.length != null) {
    length = a.length;
    if (b.length > a.length) {
      length = b.length;
    }
  } else if (a.length != null) {
    length = a.length;
  } else if (b.length != null) {
    length = b.length;
  } else {
    length = clipLength({ events: events });
  }
  return { events: events, length: length };
}

export fn repeat(c, count) {
  if (count <= 0) {
    return { events: [], length: 0 / 1 };
  }
  const len = clipLength(c);
  let events = [];
  for (i in 0..(count - 1)) {
    const offset = len * i;
    for (ev in c.events) {
      events[events.length] = shiftEvent(ev, offset);
    }
  }
  return { events: events, length: len * count };
}

export fn slice(c, startPos, endPos) {
  const start = posToRat(startPos);
  const end = posToRat(endPos);
  let events = [];
  for (ev in c.events) {
    const pos = eventStartRat(ev);
    if (pos == null) {
      continue;
    }
    // Range is [start, end) - end is exclusive per STDLIB.md
    if (pos < start || pos >= end) {
      continue;
    }
    events[events.length] = shiftEvent(ev, 0 / 1 - start);
  }
  return { events: events, length: end - start };
}

export fn mapEvents(c, f) {
  let events = [];
  for (ev in c.events) {
    const mapped = f(ev);
    if (mapped != null) {
      events[events.length] = mapped;
    }
  }
  const length = clipLength({ events: events });
  return { events: events, length: length };
}

fn copyTracks(tracks) {
  let out = [];
  for (trk in tracks) {
    out[out.length] = trk;
  }
  return out;
}

export fn withTrack(sc, trk) {
  const tracks = copyTracks(sc.tracks);
  tracks[tracks.length] = trk;
  return {
    meta: sc.meta,
    tempoMap: sc.tempoMap,
    meterMap: sc.meterMap,
    sounds: sc.sounds,
    tracks: tracks,
    markers: sc.markers
  };
}

export fn mapTracks(sc, f) {
  let tracks = [];
  for (trk in sc.tracks) {
    tracks[tracks.length] = f(trk);
  }
  return {
    meta: sc.meta,
    tempoMap: sc.tempoMap,
    meterMap: sc.meterMap,
    sounds: sc.sounds,
    tracks: tracks,
    markers: sc.markers
  };
}

// getTracks - extract all tracks from a score
export fn getTracks(sc) {
  if (sc == null) {
    return [];
  }
  if (sc.tracks != null) {
    return sc.tracks;
  }
  return [];
}

// shift - shift all event positions by offset
export fn shift(c, offset) {
  let events = [];
  for (ev in c.events) {
    events[events.length] = shiftEvent(ev, offset);
  }
  let length = null;
  if (c.length != null) {
    length = c.length;
  }
  return { events: events, length: length };
}

// padTo - extend clip length to at least endPos
export fn padTo(c, endPos) {
  const currentLen = clipLength(c);
  const target = posToRat(endPos);
  let newLength = currentLen;
  if (target != null && (currentLen == null || target > currentLen)) {
    newLength = target;
  }
  return { events: c.events, length: newLength };
}

// updateEvent - create modified copy of event with updated fields
// Usage: updateEvent(event, { start: newStart, dur: newDur, velocity: 0.8, ... })
fn getOrDefault(newVal, oldVal) {
  if (newVal != null) {
    return newVal;
  }
  return oldVal;
}

export fn updateEvent(ev, upd) {
  if (ev.type == "note") {
    return {
      type: "note",
      start: getOrDefault(upd.start, ev.start),
      dur: getOrDefault(upd.dur, ev.dur),
      pitch: getOrDefault(upd.pitch, ev.pitch),
      velocity: getOrDefault(upd.velocity, ev.velocity),
      voice: getOrDefault(upd.voice, ev.voice),
      techniques: getOrDefault(upd.techniques, ev.techniques),
      lyric: getOrDefault(upd.lyric, ev.lyric),
      ext: ev.ext
    };
  }
  if (ev.type == "chord") {
    return {
      type: "chord",
      start: getOrDefault(upd.start, ev.start),
      dur: getOrDefault(upd.dur, ev.dur),
      pitches: getOrDefault(upd.pitches, ev.pitches),
      velocity: getOrDefault(upd.velocity, ev.velocity),
      voice: getOrDefault(upd.voice, ev.voice),
      techniques: getOrDefault(upd.techniques, ev.techniques),
      ext: ev.ext
    };
  }
  if (ev.type == "drumHit") {
    return {
      type: "drumHit",
      start: getOrDefault(upd.start, ev.start),
      dur: getOrDefault(upd.dur, ev.dur),
      key: getOrDefault(upd.key, ev.key),
      velocity: getOrDefault(upd.velocity, ev.velocity),
      techniques: getOrDefault(upd.techniques, ev.techniques),
      ext: ev.ext
    };
  }
  if (ev.type == "breath") {
    return {
      type: "breath",
      start: getOrDefault(upd.start, ev.start),
      dur: getOrDefault(upd.dur, ev.dur),
      intensity: getOrDefault(upd.intensity, ev.intensity),
      ext: ev.ext
    };
  }
  if (ev.type == "control") {
    return {
      type: "control",
      start: getOrDefault(upd.start, ev.start),
      kind: getOrDefault(upd.kind, ev.kind),
      data: getOrDefault(upd.data, ev.data),
      ext: ev.ext
    };
  }
  if (ev.type == "automation") {
    return {
      type: "automation",
      param: getOrDefault(upd.param, ev.param),
      start: getOrDefault(upd.start, ev.start),
      end: getOrDefault(upd.end, ev.end),
      curve: getOrDefault(upd.curve, ev.curve),
      ext: ev.ext
    };
  }
  if (ev.type == "marker") {
    return {
      type: "marker",
      pos: getOrDefault(upd.start, ev.pos),
      kind: getOrDefault(upd.kind, ev.kind),
      label: getOrDefault(upd.label, ev.label)
    };
  }
  return ev;
}

// Utility functions

export fn max(a, b) {
  if (a > b) {
    return a;
  }
  return b;
}

export fn min(a, b) {
  if (a < b) {
    return a;
  }
  return b;
}

export fn abs(a) {
  if (a < 0) {
    return 0 - a;
  }
  return a;
}

fn floorNum(value) {
  return value - (value % 1);
}

export fn floor(a) {
  if (a.n != null && a.d != null) {
    const num = a.n / a.d;
    return floorNum(num);
  }
  return floorNum(a);
}

export fn ceil(a) {
  const f = floor(a);
  if (a.n != null && a.d != null) {
    const num = a.n / a.d;
    if (num > f) {
      return f + 1;
    }
    return f;
  }
  if (a > f) {
    return f + 1;
  }
  return f;
}

// length - returns the length of a clip
export fn length(c) {
  return clipLength(c);
}

// ============================================
// Generic Array Functions
// ============================================

// map - apply function to each element
export fn map(items, f) {
  let out = [];
  for (item in items) {
    out[out.length] = f(item);
  }
  return out;
}

// filter - keep elements matching predicate
export fn filter(items, pred) {
  let out = [];
  for (item in items) {
    if (pred(item)) {
      out[out.length] = item;
    }
  }
  return out;
}

// fold - reduce array to single value
export fn fold(items, init, f) {
  let acc = init;
  for (item in items) {
    acc = f(acc, item);
  }
  return acc;
}

// flatMap - map and flatten results
export fn flatMap(items, f) {
  let out = [];
  for (item in items) {
    const result = f(item);
    for (r in result) {
      out[out.length] = r;
    }
  }
  return out;
}

// zip - combine two arrays into array of pairs
export fn zip(a, b) {
  let out = [];
  let len = a.length;
  if (b.length < len) {
    len = b.length;
  }
  for (i in 0..(len - 1)) {
    out[out.length] = [a[i], b[i]];
  }
  return out;
}

// enumerate - add indices to elements
export fn enumerate(items) {
  let out = [];
  let i = 0;
  for (item in items) {
    out[out.length] = [i, item];
    i = i + 1;
  }
  return out;
}

// range - generate sequence of integers
export fn range(start, end, step) {
  let stepVal = step;
  if (stepVal == null) {
    stepVal = 1;
  }
  let out = [];
  if (stepVal > 0) {
    let idx = start;
    for (_ in 0..10000) {
      if (idx >= end) {
        return out;
      }
      out[out.length] = idx;
      idx = idx + stepVal;
    }
  } else if (stepVal < 0) {
    let idx = start;
    for (_ in 0..10000) {
      if (idx <= end) {
        return out;
      }
      out[out.length] = idx;
      idx = idx + stepVal;
    }
  }
  return out;
}

// find - find first element matching predicate
export fn find(items, pred) {
  for (item in items) {
    if (pred(item)) {
      return item;
    }
  }
  return null;
}

// findIndex - find index of first matching element
export fn findIndex(items, pred) {
  let i = 0;
  for (item in items) {
    if (pred(item)) {
      return i;
    }
    i = i + 1;
  }
  return -1;
}

// every - check if all elements match predicate
export fn every(items, pred) {
  for (item in items) {
    if (!pred(item)) {
      return false;
    }
  }
  return true;
}

// some - check if any element matches predicate
export fn some(items, pred) {
  for (item in items) {
    if (pred(item)) {
      return true;
    }
  }
  return false;
}

// includes - check if array contains value
export fn includes(items, value) {
  for (item in items) {
    if (item == value) {
      return true;
    }
  }
  return false;
}

// take - take first n elements
export fn take(items, n) {
  let out = [];
  let count = 0;
  for (item in items) {
    if (count >= n) {
      return out;
    }
    out[out.length] = item;
    count = count + 1;
  }
  return out;
}

// drop - drop first n elements
export fn drop(items, n) {
  let out = [];
  let count = 0;
  for (item in items) {
    if (count >= n) {
      out[out.length] = item;
    }
    count = count + 1;
  }
  return out;
}

// ============================================
// Extended Clip Operations
// ============================================

// merge - overlay multiple clips at once
export fn merge(clips) {
  if (clips.length == 0) {
    return { events: [], length: 0 / 1 };
  }
  let result = clips[0];
  for (i in 1..(clips.length - 1)) {
    result = overlay(result, clips[i]);
  }
  return result;
}

// reverse - reverse the temporal order of events
export fn reverse(c) {
  const len = clipLength(c);
  if (len == null) {
    return c;
  }
  let events = [];
  for (ev in c.events) {
    const start = eventStartRat(ev);
    const evEnd = eventEndRat(ev);
    if (start == null || evEnd == null) {
      events[events.length] = ev;
      continue;
    }
    const dur = evEnd - start;
    const newStart = len - evEnd;
    events[events.length] = shiftEvent(updateEvent(ev, { start: newStart }), 0 / 1);
  }
  return { events: events, length: len };
}

// invert - invert pitches around an axis
export fn invert(c, axis) {
  let events = [];
  for (ev in c.events) {
    if (ev.type == "note") {
      const newPitch = axis * 2 - ev.pitch;
      events[events.length] = updateEvent(ev, { pitch: newPitch });
    } else if (ev.type == "chord") {
      let newPitches = [];
      for (p in ev.pitches) {
        newPitches[newPitches.length] = axis * 2 - p;
      }
      events[events.length] = updateEvent(ev, { pitches: newPitches });
    } else {
      events[events.length] = ev;
    }
  }
  return { events: events, length: c.length };
}

// retrograde - alias for reverse (music theory term)
export fn retrograde(c) {
  return reverse(c);
}

// split - split clip at given positions into multiple clips
export fn split(c, positions) {
  if (positions.length == 0) {
    return [c];
  }
  // Sort positions
  let sorted = [];
  for (p in positions) {
    sorted[sorted.length] = posToRat(p);
  }
  // Simple bubble sort
  for (i in 0..(sorted.length - 1)) {
    for (j in 0..(sorted.length - i - 2)) {
      if (sorted[j] > sorted[j + 1]) {
        const tmp = sorted[j];
        sorted[j] = sorted[j + 1];
        sorted[j + 1] = tmp;
      }
    }
  }

  let result = [];
  let prevPos = 0 / 1;
  for (pos in sorted) {
    if (pos > prevPos) {
      result[result.length] = slice(c, prevPos, pos);
    }
    prevPos = pos;
  }
  // Add remaining
  const len = clipLength(c);
  if (len != null && prevPos < len) {
    result[result.length] = slice(c, prevPos, len);
  }
  return result;
}

// augment - double all durations (augmentation in music theory)
export fn augment(c, factor) {
  let f = factor;
  if (f == null) {
    f = 2;
  }
  let events = [];
  for (ev in c.events) {
    if (ev.type == "note" || ev.type == "chord" || ev.type == "drumHit" || ev.type == "breath") {
      const newStart = eventStartRat(ev) * f;
      const newDur = ev.dur * f;
      events[events.length] = updateEvent(ev, { start: newStart, dur: newDur });
    } else if (ev.type == "automation") {
      const newStart = eventStartRat(ev) * f;
      const newEnd = posToRat(ev.end) * f;
      events[events.length] = updateEvent(ev, { start: newStart, end: newEnd });
    } else if (ev.type == "marker") {
      const newPos = posToRat(ev.pos) * f;
      events[events.length] = { type: "marker", pos: newPos, kind: ev.kind, label: ev.label };
    } else if (ev.type == "control") {
      const newStart = eventStartRat(ev) * f;
      events[events.length] = updateEvent(ev, { start: newStart });
    } else {
      events[events.length] = ev;
    }
  }
  let newLen = null;
  if (c.length != null) {
    newLen = c.length * f;
  }
  return { events: events, length: newLen };
}

// diminish - halve all durations (diminution in music theory)
export fn diminish(c, factor) {
  let f = factor;
  if (f == null) {
    f = 2;
  }
  return augment(c, 1 / f);
}
