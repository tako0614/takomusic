// std:vocal (v4)

export const Strict = "Strict";
export const BestEffort = "BestEffort";
export const MelismaHeuristic = "MelismaHeuristic";

fn syllable(text) {
  return { kind: "syllable", text: text };
}

export fn S(text) {
  return syllable(text);
}

export fn ext() {
  return { kind: "extend" };
}

export const Ext = ext();

fn containsSpace(text) {
  for (i in 0..(text.length - 1)) {
    if (text[i] == " ") {
      return true;
    }
  }
  return false;
}

export fn text(text, lang) {
  let useLang = lang;
  if (useLang == null) {
    useLang = "und";
  }
  let src = text;
  if (src == null) {
    src = "";
  }
  let tokens = [];
  if (containsSpace(src)) {
    let current = "";
    for (i in 0..(src.length - 1)) {
      const ch = src[i];
      if (ch == " ") {
        if (current != "") {
          tokens[tokens.length] = syllable(current);
          current = "";
        }
      } else {
        current = current + ch;
      }
    }
    if (current != "") {
      tokens[tokens.length] = syllable(current);
    }
  } else {
    for (i in 0..(src.length - 1)) {
      tokens[tokens.length] = syllable(src[i]);
    }
  }
  return { kind: "text", tokens: tokens, lang: useLang };
}

export fn syllables(tokens, lang, words) {
  let useLang = lang;
  if (useLang == null) {
    useLang = "und";
  }
  let out = [];
  let items = tokens;
  if (items == null) {
    items = [];
  }
  for (item in items) {
    if (item.kind == "extend") {
      out[out.length] = item;
    } else if (item.kind == "syllable") {
      out[out.length] = item;
    } else {
      out[out.length] = syllable(item);
    }
  }
  let result = { kind: "syllables", tokens: out, lang: useLang };
  if (words != null) {
    result.words = words;
  }
  return result;
}

fn joinGroup(group) {
  let out = "";
  if (group == null) {
    return out;
  }
  for (i in 0..(group.length - 1)) {
    if (i > 0) {
      out = out + " ";
    }
    out = out + group[i];
  }
  return out;
}

export fn phonemes(groups, lang, alphabet, words) {
  let useLang = lang;
  if (useLang == null) {
    useLang = "und";
  }
  let out = [];
  let list = groups;
  if (list == null) {
    list = [];
  }
  for (g in list) {
    out[out.length] = syllable(joinGroup(g));
  }
  let result = { kind: "phonemes", tokens: out, lang: useLang };
  if (alphabet != null) {
    result.alphabet = alphabet;
  }
  if (words != null) {
    result.words = words;
  }
  return result;
}

fn cloneEvent(ev) {
  if (ev.type == "note") {
    return {
      type: "note",
      start: ev.start,
      dur: ev.dur,
      pitch: ev.pitch,
      velocity: ev.velocity,
      voice: ev.voice,
      techniques: ev.techniques,
      lyric: ev.lyric,
      ext: ev.ext
    };
  }
  if (ev.type == "chord") {
    return {
      type: "chord",
      start: ev.start,
      dur: ev.dur,
      pitches: ev.pitches,
      velocity: ev.velocity,
      voice: ev.voice,
      techniques: ev.techniques,
      ext: ev.ext
    };
  }
  if (ev.type == "drumHit") {
    return {
      type: "drumHit",
      start: ev.start,
      dur: ev.dur,
      key: ev.key,
      velocity: ev.velocity,
      techniques: ev.techniques,
      ext: ev.ext
    };
  }
  if (ev.type == "control") {
    return {
      type: "control",
      start: ev.start,
      kind: ev.kind,
      data: ev.data,
      ext: ev.ext
    };
  }
  if (ev.type == "automation") {
    return {
      type: "automation",
      param: ev.param,
      start: ev.start,
      end: ev.end,
      curve: ev.curve,
      ext: ev.ext
    };
  }
  if (ev.type == "marker") {
    return {
      type: "marker",
      pos: ev.pos,
      kind: ev.kind,
      label: ev.label
    };
  }
  if (ev.type == "breath") {
    return {
      type: "breath",
      start: ev.start,
      dur: ev.dur,
      intensity: ev.intensity,
      ext: ev.ext
    };
  }
  return ev;
}

export fn align(c, lyric, policy) {
  let tokens = lyric.tokens;
  if (tokens == null) {
    tokens = [];
  }
  let idx = 0;
  let events = [];
  for (ev in c.events) {
    if (ev.type == "note") {
      let out = cloneEvent(ev);
      const token = tokens[idx];
      if (token != null) {
        out.lyric = token;
        idx = idx + 1;
      }
      events[events.length] = out;
    } else {
      events[events.length] = cloneEvent(ev);
    }
  }
  return { events: events, length: c.length };
}

fn posToRat(pos) {
  if (pos == null) {
    return null;
  }
  if (pos.kind == "rat") {
    return pos.rat;
  }
  if (pos.kind != null) {
    return null;
  }
  if (pos.n != null && pos.d != null) {
    return pos;
  }
  return null;
}

fn eventEndRat(ev) {
  if (ev.type == "note" || ev.type == "chord" || ev.type == "drumHit" || ev.type == "breath") {
    const start = posToRat(ev.start);
    if (start == null) {
      return null;
    }
    return start + ev.dur;
  }
  if (ev.type == "control") {
    return posToRat(ev.start);
  }
  if (ev.type == "automation") {
    return posToRat(ev.end);
  }
  if (ev.type == "marker") {
    return posToRat(ev.pos);
  }
  return null;
}

fn clipLength(c) {
  if (c.length != null) {
    return c.length;
  }
  let max = null;
  for (ev in c.events) {
    const end = eventEndRat(ev);
    if (end == null) {
      return null;
    }
    if (max == null || end > max) {
      max = end;
    }
  }
  if (max == null) {
    return 0 / 1;
  }
  return max;
}

fn defaultEnd(c) {
  const len = clipLength(c);
  if (len == null) {
    return 0 / 1;
  }
  return len;
}

fn flatCurve(amount) {
  return {
    kind: "piecewiseLinear",
    points: [
      { t: 0, v: amount },
      { t: 1, v: amount }
    ]
  };
}

fn addAutomation(c, param, amount, start, end) {
  let depth = amount;
  if (depth == null) {
    depth = 1;
  }
  let startPos = start;
  if (startPos == null) {
    startPos = 0 / 1;
  }
  let endPos = end;
  if (endPos == null) {
    endPos = defaultEnd(c);
  }
  let events = [];
  for (ev in c.events) {
    events[events.length] = cloneEvent(ev);
  }
  events[events.length] = {
    type: "automation",
    param: param,
    start: startPos,
    end: endPos,
    curve: flatCurve(depth)
  };
  return { events: events, length: c.length };
}

export fn vibrato(c, depth, rate, start, end) {
  let out = addAutomation(c, "vocal:vibratoDepth", depth, start, end);
  if (rate != null) {
    out = addAutomation(out, "vocal:vibratoRate", rate, start, end);
  }
  return out;
}

export fn portamento(c, amount, start, end) {
  return addAutomation(c, "vocal:portamento", amount, start, end);
}

export fn breathiness(c, amount, start, end) {
  return addAutomation(c, "vocal:breathiness", amount, start, end);
}

export fn loudness(c, curve, start, end) {
  let startPos = start;
  if (startPos == null) {
    startPos = 0 / 1;
  }
  let endPos = end;
  if (endPos == null) {
    endPos = defaultEnd(c);
  }
  let events = [];
  for (ev in c.events) {
    events[events.length] = cloneEvent(ev);
  }
  events[events.length] = {
    type: "automation",
    param: "vocal:loudness",
    start: startPos,
    end: endPos,
    curve: curve
  };
  return { events: events, length: c.length };
}

// autoBreath: automatically insert breath events before phrases
// Options:
//   minGap: Dur - minimum gap between notes to insert breath (default: s = 1/16)
//   breathDur: Dur - duration of inserted breath (default: s = 1/16)
//   intensity: Float - breath intensity 0..1 (default: 0.6)
//   shortenPrev: Bool - shorten previous note to make room for breath (default: true)
export fn autoBreath(c, opts) {
  // Parse options with defaults
  let minGap = 1 / 16;
  let breathDur = 1 / 16;
  let intensity = 0.6;
  let shortenPrev = true;

  if (opts != null) {
    if (opts.minGap != null) {
      minGap = opts.minGap;
    }
    if (opts.breathDur != null) {
      breathDur = opts.breathDur;
    }
    if (opts.intensity != null) {
      intensity = opts.intensity;
    }
    if (opts.shortenPrev != null) {
      shortenPrev = opts.shortenPrev;
    }
  }

  // Collect note events with their indices, sorted by start time
  let notes = [];
  let otherEvents = [];

  for (ev in c.events) {
    if (ev.type == "note") {
      const start = posToRat(ev.start);
      if (start != null) {
        notes[notes.length] = {
          event: cloneEvent(ev),
          start: start,
          end: start + ev.dur
        };
      } else {
        otherEvents[otherEvents.length] = cloneEvent(ev);
      }
    } else {
      otherEvents[otherEvents.length] = cloneEvent(ev);
    }
  }

  // Sort notes by start time (simple bubble sort)
  for (i in 0..(notes.length - 1)) {
    for (j in 0..(notes.length - i - 2)) {
      if (notes[j].start > notes[j + 1].start) {
        const tmp = notes[j];
        notes[j] = notes[j + 1];
        notes[j + 1] = tmp;
      }
    }
  }

  // Build result with breaths inserted
  let result = [];
  let breaths = [];

  // Check if we should add breath at the very beginning
  if (notes.length > 0) {
    const firstStart = notes[0].start;
    if (firstStart >= breathDur) {
      // There's room for a breath before the first note
      breaths[breaths.length] = {
        type: "breath",
        start: firstStart - breathDur,
        dur: breathDur,
        intensity: intensity
      };
    }
  }

  // Scan through notes and insert breaths where gaps are large enough
  for (i in 0..(notes.length - 2)) {
    const current = notes[i];
    const next = notes[i + 1];
    const gap = next.start - current.end;

    if (gap >= minGap) {
      // Gap is large enough, insert breath before next note
      let breathStart = next.start - breathDur;

      // If shortenPrev and breath would start before current note ends,
      // shorten the current note
      if (shortenPrev && breathStart < current.end) {
        const newEnd = breathStart;
        const newDur = newEnd - current.start;
        if (newDur > 0 / 1) {
          current.event.dur = newDur;
          current.end = newEnd;
          breathStart = newEnd;
        }
      }

      // Only add breath if it fits
      if (breathStart >= current.end && breathStart + breathDur <= next.start) {
        breaths[breaths.length] = {
          type: "breath",
          start: breathStart,
          dur: breathDur,
          intensity: intensity
        };
      }
    }
  }

  // Collect all events: other events, modified notes, and breaths
  for (ev in otherEvents) {
    result[result.length] = ev;
  }
  for (n in notes) {
    result[result.length] = n.event;
  }
  for (b in breaths) {
    result[result.length] = b;
  }

  return { events: result, length: c.length };
}
