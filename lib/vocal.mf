// std:vocal (v3)

export const Strict = "Strict";
export const BestEffort = "BestEffort";
export const MelismaHeuristic = "MelismaHeuristic";

fn syllable(text) {
  return { kind: "syllable", text: text };
}

export fn S(text) {
  return syllable(text);
}

export fn ext() {
  return { kind: "extend" };
}

export const Ext = ext();

fn containsSpace(text) {
  for (i in 0..(text.length - 1)) {
    if (text[i] == " ") {
      return true;
    }
  }
  return false;
}

export fn text(text, lang) {
  let useLang = lang;
  if (useLang == null) {
    useLang = "und";
  }
  let src = text;
  if (src == null) {
    src = "";
  }
  let tokens = [];
  if (containsSpace(src)) {
    let current = "";
    for (i in 0..(src.length - 1)) {
      const ch = src[i];
      if (ch == " ") {
        if (current != "") {
          tokens[tokens.length] = syllable(current);
          current = "";
        }
      } else {
        current = current + ch;
      }
    }
    if (current != "") {
      tokens[tokens.length] = syllable(current);
    }
  } else {
    for (i in 0..(src.length - 1)) {
      tokens[tokens.length] = syllable(src[i]);
    }
  }
  return { kind: "text", tokens: tokens, lang: useLang };
}

export fn syllables(tokens, lang, words) {
  let useLang = lang;
  if (useLang == null) {
    useLang = "und";
  }
  let out = [];
  let items = tokens;
  if (items == null) {
    items = [];
  }
  for (item in items) {
    if (item.kind == "extend") {
      out[out.length] = item;
    } else if (item.kind == "syllable") {
      out[out.length] = item;
    } else {
      out[out.length] = syllable(item);
    }
  }
  let result = { kind: "syllables", tokens: out, lang: useLang };
  if (words != null) {
    result.words = words;
  }
  return result;
}

fn joinGroup(group) {
  let out = "";
  if (group == null) {
    return out;
  }
  for (i in 0..(group.length - 1)) {
    if (i > 0) {
      out = out + " ";
    }
    out = out + group[i];
  }
  return out;
}

export fn phonemes(groups, lang, alphabet, words) {
  let useLang = lang;
  if (useLang == null) {
    useLang = "und";
  }
  let out = [];
  let list = groups;
  if (list == null) {
    list = [];
  }
  for (g in list) {
    out[out.length] = syllable(joinGroup(g));
  }
  let result = { kind: "phonemes", tokens: out, lang: useLang };
  if (alphabet != null) {
    result.alphabet = alphabet;
  }
  if (words != null) {
    result.words = words;
  }
  return result;
}

fn cloneEvent(ev) {
  if (ev.type == "note") {
    return {
      type: "note",
      start: ev.start,
      dur: ev.dur,
      pitch: ev.pitch,
      velocity: ev.velocity,
      voice: ev.voice,
      techniques: ev.techniques,
      lyric: ev.lyric,
      ext: ev.ext
    };
  }
  if (ev.type == "chord") {
    return {
      type: "chord",
      start: ev.start,
      dur: ev.dur,
      pitches: ev.pitches,
      velocity: ev.velocity,
      voice: ev.voice,
      techniques: ev.techniques,
      ext: ev.ext
    };
  }
  if (ev.type == "drumHit") {
    return {
      type: "drumHit",
      start: ev.start,
      dur: ev.dur,
      key: ev.key,
      velocity: ev.velocity,
      techniques: ev.techniques,
      ext: ev.ext
    };
  }
  if (ev.type == "control") {
    return {
      type: "control",
      start: ev.start,
      kind: ev.kind,
      data: ev.data,
      ext: ev.ext
    };
  }
  if (ev.type == "automation") {
    return {
      type: "automation",
      param: ev.param,
      start: ev.start,
      end: ev.end,
      curve: ev.curve,
      ext: ev.ext
    };
  }
  if (ev.type == "marker") {
    return {
      type: "marker",
      pos: ev.pos,
      kind: ev.kind,
      label: ev.label
    };
  }
  return ev;
}

export fn align(c, lyric, policy) {
  let tokens = lyric.tokens;
  if (tokens == null) {
    tokens = [];
  }
  let idx = 0;
  let events = [];
  for (ev in c.events) {
    if (ev.type == "note") {
      let out = cloneEvent(ev);
      const token = tokens[idx];
      if (token != null) {
        out.lyric = token;
        idx = idx + 1;
      }
      events[events.length] = out;
    } else {
      events[events.length] = cloneEvent(ev);
    }
  }
  return { events: events, length: c.length };
}

fn posToRat(pos) {
  if (pos == null) {
    return null;
  }
  if (pos.kind == "rat") {
    return pos.rat;
  }
  if (pos.kind != null) {
    return null;
  }
  if (pos.n != null && pos.d != null) {
    return pos;
  }
  return null;
}

fn eventEndRat(ev) {
  if (ev.type == "note" || ev.type == "chord" || ev.type == "drumHit") {
    const start = posToRat(ev.start);
    if (start == null) {
      return null;
    }
    return start + ev.dur;
  }
  if (ev.type == "control") {
    return posToRat(ev.start);
  }
  if (ev.type == "automation") {
    return posToRat(ev.end);
  }
  if (ev.type == "marker") {
    return posToRat(ev.pos);
  }
  return null;
}

fn clipLength(c) {
  if (c.length != null) {
    return c.length;
  }
  let max = null;
  for (ev in c.events) {
    const end = eventEndRat(ev);
    if (end == null) {
      return null;
    }
    if (max == null || end > max) {
      max = end;
    }
  }
  if (max == null) {
    return 0 / 1;
  }
  return max;
}

fn defaultEnd(c) {
  const len = clipLength(c);
  if (len == null) {
    return 0 / 1;
  }
  return len;
}

fn flatCurve(amount) {
  return {
    kind: "piecewiseLinear",
    points: [
      { t: 0, v: amount },
      { t: 1, v: amount }
    ]
  };
}

fn addAutomation(c, param, amount, start, end) {
  let depth = amount;
  if (depth == null) {
    depth = 1;
  }
  let startPos = start;
  if (startPos == null) {
    startPos = 0 / 1;
  }
  let endPos = end;
  if (endPos == null) {
    endPos = defaultEnd(c);
  }
  let events = [];
  for (ev in c.events) {
    events[events.length] = cloneEvent(ev);
  }
  events[events.length] = {
    type: "automation",
    param: param,
    start: startPos,
    end: endPos,
    curve: flatCurve(depth)
  };
  return { events: events, length: c.length };
}

export fn vibrato(c, depth, rate, start, end) {
  let out = addAutomation(c, "vocal:vibratoDepth", depth, start, end);
  if (rate != null) {
    out = addAutomation(out, "vocal:vibratoRate", rate, start, end);
  }
  return out;
}

export fn portamento(c, amount, start, end) {
  return addAutomation(c, "vocal:portamento", amount, start, end);
}

export fn breathiness(c, amount, start, end) {
  return addAutomation(c, "vocal:breathiness", amount, start, end);
}

export fn loudness(c, curve, start, end) {
  let startPos = start;
  if (startPos == null) {
    startPos = 0 / 1;
  }
  let endPos = end;
  if (endPos == null) {
    endPos = defaultEnd(c);
  }
  let events = [];
  for (ev in c.events) {
    events[events.length] = cloneEvent(ev);
  }
  events[events.length] = {
    type: "automation",
    param: "vocal:loudness",
    start: startPos,
    end: endPos,
    curve: curve
  };
  return { events: events, length: c.length };
}
