// MFS Standard Library - Chords
// Functions for building and playing chords

// Chord intervals from root (in semitones)

// Major triad: 1 - 3 - 5
export proc chordMajor(root) {
  let m = pitchMidi(root);
  return [midiPitch(m), midiPitch(m + 4), midiPitch(m + 7)];
}

// Minor triad: 1 - b3 - 5
export proc chordMinor(root) {
  let m = pitchMidi(root);
  return [midiPitch(m), midiPitch(m + 3), midiPitch(m + 7)];
}

// Diminished triad: 1 - b3 - b5
export proc chordDim(root) {
  let m = pitchMidi(root);
  return [midiPitch(m), midiPitch(m + 3), midiPitch(m + 6)];
}

// Augmented triad: 1 - 3 - #5
export proc chordAug(root) {
  let m = pitchMidi(root);
  return [midiPitch(m), midiPitch(m + 4), midiPitch(m + 8)];
}

// Major 7th: 1 - 3 - 5 - 7
export proc chordMaj7(root) {
  let m = pitchMidi(root);
  return [midiPitch(m), midiPitch(m + 4), midiPitch(m + 7), midiPitch(m + 11)];
}

// Minor 7th: 1 - b3 - 5 - b7
export proc chordMin7(root) {
  let m = pitchMidi(root);
  return [midiPitch(m), midiPitch(m + 3), midiPitch(m + 7), midiPitch(m + 10)];
}

// Dominant 7th: 1 - 3 - 5 - b7
export proc chordDom7(root) {
  let m = pitchMidi(root);
  return [midiPitch(m), midiPitch(m + 4), midiPitch(m + 7), midiPitch(m + 10)];
}

// Half-diminished 7th: 1 - b3 - b5 - b7
export proc chordHalfDim7(root) {
  let m = pitchMidi(root);
  return [midiPitch(m), midiPitch(m + 3), midiPitch(m + 6), midiPitch(m + 10)];
}

// Diminished 7th: 1 - b3 - b5 - bb7
export proc chordDim7(root) {
  let m = pitchMidi(root);
  return [midiPitch(m), midiPitch(m + 3), midiPitch(m + 6), midiPitch(m + 9)];
}

// Suspended 2nd: 1 - 2 - 5
export proc chordSus2(root) {
  let m = pitchMidi(root);
  return [midiPitch(m), midiPitch(m + 2), midiPitch(m + 7)];
}

// Suspended 4th: 1 - 4 - 5
export proc chordSus4(root) {
  let m = pitchMidi(root);
  return [midiPitch(m), midiPitch(m + 5), midiPitch(m + 7)];
}

// Add9: 1 - 3 - 5 - 9
export proc chordAdd9(root) {
  let m = pitchMidi(root);
  return [midiPitch(m), midiPitch(m + 4), midiPitch(m + 7), midiPitch(m + 14)];
}

// 9th: 1 - 3 - 5 - b7 - 9
export proc chord9(root) {
  let m = pitchMidi(root);
  return [midiPitch(m), midiPitch(m + 4), midiPitch(m + 7), midiPitch(m + 10), midiPitch(m + 14)];
}

// Minor 9th: 1 - b3 - 5 - b7 - 9
export proc chordMin9(root) {
  let m = pitchMidi(root);
  return [midiPitch(m), midiPitch(m + 3), midiPitch(m + 7), midiPitch(m + 10), midiPitch(m + 14)];
}

// Major 9th: 1 - 3 - 5 - 7 - 9
export proc chordMaj9(root) {
  let m = pitchMidi(root);
  return [midiPitch(m), midiPitch(m + 4), midiPitch(m + 7), midiPitch(m + 11), midiPitch(m + 14)];
}

// Power chord (5th): 1 - 5
export proc chordPower(root) {
  let m = pitchMidi(root);
  return [midiPitch(m), midiPitch(m + 7)];
}

// Power chord with octave: 1 - 5 - 8
export proc chordPower8(root) {
  let m = pitchMidi(root);
  return [midiPitch(m), midiPitch(m + 7), midiPitch(m + 12)];
}

// ===== Chord voicing utilities =====

// Invert chord (move lowest note up an octave)
// chord: array of pitches
// times: number of inversions (default 1)
export proc invert(chord, times) {
  let result = copy(chord);
  for (i in 0..times) {
    if (len(result) > 0) {
      let lowest = result[0];
      let newPitch = midiPitch(pitchMidi(lowest) + 12);
      // Shift array left and append
      for (j in 0..(len(result) - 1)) {
        result[j] = result[j + 1];
      }
      result[len(result) - 1] = newPitch;
    }
  }
  return result;
}

// Drop 2 voicing (move 2nd highest note down an octave)
export proc drop2(chord) {
  if (len(chord) < 3) {
    return chord;
  }
  let result = copy(chord);
  let idx = len(result) - 2;
  let note = result[idx];
  result[idx] = midiPitch(pitchMidi(note) - 12);
  return result;
}

// Transpose entire chord
// chord: array of pitches
// semitones: amount to transpose
export proc transposeChord(chord, semitones) {
  let result = [];
  for (p in chord) {
    push(result, transpose(p, semitones));
  }
  return result;
}

// ===== Chord playback utilities =====

// playChord: Play all notes of a chord simultaneously
// chord: array of pitches
// dur: duration
export proc playChord(chord, dur) {
  let durTicks = durToTicks(dur);
  let vel = getVel();
  let tick = cursor();

  for (p in chord) {
    noteAt(tick, p, durTicks, vel);
  }
  advanceTick(durTicks);
}

// strumChord: Strum chord with delay between notes
// chord: array of pitches
// dur: total duration
// strumDelay: ticks between each note
// downStrum: true for low-to-high, false for high-to-low
export proc strumChord(chord, dur, strumDelay, downStrum) {
  let durTicks = durToTicks(dur);
  let vel = getVel();
  let startTick = cursor();
  let n = len(chord);

  if (downStrum) {
    for (i in 0..n) {
      let noteTick = startTick + i * strumDelay;
      let noteDur = durTicks - i * strumDelay;
      if (noteDur > 0) {
        noteAt(noteTick, chord[i], noteDur, vel);
      }
    }
  } else {
    for (i in 0..n) {
      let idx = n - 1 - i;
      let noteTick = startTick + i * strumDelay;
      let noteDur = durTicks - i * strumDelay;
      if (noteDur > 0) {
        noteAt(noteTick, chord[idx], noteDur, vel);
      }
    }
  }
  advanceTick(durTicks);
}

// arpeggiate: Play chord notes sequentially
// chord: array of pitches
// noteDur: duration of each note
export proc arpeggiate(chord, noteDur) {
  let durTicks = durToTicks(noteDur);
  let vel = getVel();

  for (p in chord) {
    noteAt(cursor(), p, durTicks, vel);
    advanceTick(durTicks);
  }
}

// arpeggiatePattern: Arpeggiate with pattern
// chord: array of pitches
// pattern: array of indices (e.g., [0, 1, 2, 1] for up-down)
// noteDur: duration per note
export proc arpeggiatePattern(chord, pattern, noteDur) {
  let durTicks = durToTicks(noteDur);
  let vel = getVel();
  let n = len(chord);

  for (idx in pattern) {
    if (idx >= 0) {
      let actualIdx = idx % n;
      noteAt(cursor(), chord[actualIdx], durTicks, vel);
    }
    advanceTick(durTicks);
  }
}
