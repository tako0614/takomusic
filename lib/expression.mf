// Expression functions for TakoMusic
// Pitch bend, modulation, and expressive techniques

import { clip, lerp } from "./utils.mf";

// Vibrato using pitch bend
// depth: semitones (e.g., 0.5 for half semitone)
// rate: oscillations per beat
export proc vibrato(pitch, dur, depth, rate) {
  const ticks = durToTicks(dur);
  const cycles = floor(rate * 4);
  const steps = cycles * 8;
  const stepTicks = floor(ticks / steps);

  // Play the note
  note(pitch, dur);

  // Apply pitch bend oscillation
  at(cursor());
  advanceTick(-ticks);

  for (i in 0..steps) {
    const phase = (i % 8) / 8;
    let bend = 0;

    // Sine-like approximation
    if (phase < 0.25) {
      bend = phase * 4;
    } else {
      if (phase < 0.75) {
        bend = 1 - (phase - 0.25) * 4;
      } else {
        bend = -1 + (phase - 0.75) * 4;
      }
    }

    const bendVal = floor(8192 + bend * depth * 4096);
    pitchBend(clip(bendVal, 0, 16383));
    advanceTick(stepTicks);
  }

  // Reset pitch bend
  pitchBend(8192);
}

// Simple vibrato (fewer parameters)
export proc vibratoSimple(pitch, dur) {
  vibrato(pitch, dur, 0.3, 5);
}

// Portamento / glide between two pitches
export proc portamento(fromPitch, toPitch, dur) {
  const fromMidi = pitchMidi(fromPitch);
  const toMidi = pitchMidi(toPitch);
  const semitones = toMidi - fromMidi;
  const ticks = durToTicks(dur);
  const steps = 16;
  const stepTicks = floor(ticks / steps);

  // Start from the first pitch
  note(fromPitch, dur);

  // Glide using pitch bend
  at(cursor());
  advanceTick(-ticks);

  for (i in 0..=steps) {
    const t = i / steps;
    const bendSemitones = semitones * t;
    const bendVal = floor(8192 + bendSemitones * 4096 / 2);
    pitchBend(clip(bendVal, 0, 16383));
    advanceTick(stepTicks);
  }

  // Reset
  pitchBend(8192);
}

// Bend up to pitch
export proc bendUp(pitch, dur, semitones) {
  const ticks = durToTicks(dur);
  const steps = 8;
  const stepTicks = floor(ticks / steps);

  // Start with bend down
  pitchBend(floor(8192 - semitones * 4096 / 2));
  note(pitch, dur);

  // Bend up to normal
  at(cursor());
  advanceTick(-ticks);

  for (i in 0..=steps) {
    const t = i / steps;
    const bendVal = floor(8192 - semitones * (1 - t) * 4096 / 2);
    pitchBend(clip(bendVal, 0, 16383));
    advanceTick(stepTicks);
  }

  pitchBend(8192);
}

// Bend down from pitch
export proc bendDown(pitch, dur, semitones) {
  const ticks = durToTicks(dur);
  const steps = 8;
  const stepTicks = floor(ticks / steps);

  note(pitch, dur);

  at(cursor());
  advanceTick(-ticks);

  for (i in 0..=steps) {
    const t = i / steps;
    const bendVal = floor(8192 - semitones * t * 4096 / 2);
    pitchBend(clip(bendVal, 0, 16383));
    advanceTick(stepTicks);
  }

  pitchBend(8192);
}

// Scoop - quick bend up into note
export proc scoop(pitch, dur, semitones) {
  bendUp(pitch, dur, semitones);
}

// Fall - bend down at end of note
export proc fall(pitch, dur, semitones) {
  const mainDur = dur * 3/4;
  const fallDur = dur * 1/4;

  note(pitch, mainDur);

  const ticks = durToTicks(fallDur);
  const steps = 4;
  const stepTicks = floor(ticks / steps);

  for (i in 0..=steps) {
    const t = i / steps;
    const bendVal = floor(8192 - semitones * t * 4096 / 2);
    pitchBend(clip(bendVal, 0, 16383));
    advanceTick(stepTicks);
  }

  pitchBend(8192);
}

// Modulation wheel automation
export proc modulationSwell(startVal, peakVal, dur) {
  const ticks = durToTicks(dur);
  const halfTicks = floor(ticks / 2);
  const steps = 8;

  // Increase
  for (i in 0..=steps) {
    const t = i / steps;
    const val = floor(lerp(startVal, peakVal, t));
    atTick(floor(halfTicks * t));
    modulation(clip(val, 0, 127));
  }

  // Decrease
  for (i in 0..=steps) {
    const t = i / steps;
    const val = floor(lerp(peakVal, startVal, t));
    atTick(halfTicks + floor(halfTicks * t));
    modulation(clip(val, 0, 127));
  }
}

// Breath controller (CC2)
export proc breathController(startVal, endVal, dur) {
  const ticks = durToTicks(dur);
  const steps = 16;

  for (i in 0..=steps) {
    const t = i / steps;
    const val = floor(lerp(startVal, endVal, t));
    atTick(floor(ticks * t));
    cc(2, clip(val, 0, 127));
  }
}

// Tremolo using modulation
export proc tremoloMod(pitch, dur, depth, rate) {
  const ticks = durToTicks(dur);
  const cycles = floor(rate * 4);
  const steps = cycles * 4;
  const stepTicks = floor(ticks / steps);

  note(pitch, dur);

  at(cursor());
  advanceTick(-ticks);

  for (i in 0..steps) {
    const phase = (i % 4) / 4;
    let val = 0;

    if (phase < 0.5) {
      val = floor(depth * phase * 2);
    } else {
      val = floor(depth * (1 - (phase - 0.5) * 2));
    }

    modulation(clip(val, 0, 127));
    advanceTick(stepTicks);
  }

  modulation(0);
}

// Legato transition between notes
export proc legatoSlide(fromPitch, toPitch, dur, slideDur) {
  const mainDur = dur - slideDur;

  note(fromPitch, mainDur);
  portamento(fromPitch, toPitch, slideDur);
}
