// Utility functions for TakoMusic
// General-purpose helper functions

// Constrain value between min and max
export proc clip(val, minVal, maxVal) {
  return min(max(val, minVal), maxVal);
}

// Linear interpolation between a and b
export proc lerp(a, b, t) {
  return a + (b - a) * t;
}

// Rescale value from input range to output range
export proc rescale(val, inMin, inMax, outMin, outMax) {
  const t = (val - inMin) / (inMax - inMin);
  return lerp(outMin, outMax, t);
}

// Quantize value to nearest step
export proc quantize(val, step) {
  return floor(val / step) * step;
}

// Wrap value to range [min, max)
export proc wrap(val, minVal, maxVal) {
  const range = maxVal - minVal;
  let result = val;
  if (result < minVal) {
    result = result + range * ceil((minVal - result) / range);
  }
  if (result >= maxVal) {
    result = result - range * floor((result - minVal) / range);
  }
  return result;
}

// Sign function: returns -1, 0, or 1
export proc sign(val) {
  if (val > 0) { return 1; }
  if (val < 0) { return -1; }
  return 0;
}

// Randomize velocity with variation
export proc randomizeVel(baseVel, variation) {
  const offset = floor((random() - 0.5) * variation * 2);
  return clip(baseVel + offset, 1, 127);
}

// Random choice from array
export proc choice(arr) {
  const idx = random(len(arr));
  return arr[idx];
}

// Shuffle array (Fisher-Yates)
export proc shuffle(arr) {
  let result = copy(arr);
  for (i in 0..len(result) - 1) {
    const j = i + random(len(result) - i);
    const temp = result[i];
    result[i] = result[j];
    result[j] = temp;
  }
  return result;
}

// Sum of array elements
export proc sum(arr) {
  return reduce(arr, (acc, x) => acc + x, 0);
}

// Average of array elements
export proc average(arr) {
  if (len(arr) == 0) { return 0; }
  return sum(arr) / len(arr);
}

// Normalize array to range [0, 1]
export proc normalize(arr) {
  const minVal = reduce(arr, (a, b) => min(a, b), arr[0]);
  const maxVal = reduce(arr, (a, b) => max(a, b), arr[0]);
  const range = maxVal - minVal;
  if (range == 0) { return fill(len(arr), 0.5); }
  return map(arr, (x) => (x - minVal) / range);
}

// Zip two arrays into array of pairs
export proc zip(arr1, arr2) {
  const minLen = min(len(arr1), len(arr2));
  let result = [];
  for (i in 0..minLen) {
    push(result, [arr1[i], arr2[i]]);
  }
  return result;
}

// Repeat pattern n times
export proc repeatPattern(pattern, n) {
  let result = [];
  for (i in 0..n) {
    for (j in 0..len(pattern)) {
      push(result, pattern[j]);
    }
  }
  return result;
}

// Rotate array by n positions
export proc rotate(arr, n) {
  const len = len(arr);
  if (len == 0) { return []; }
  const shift = n % len;
  const idx = (len - shift) % len;
  return concat(slice(arr, idx, len), slice(arr, 0, idx));
}

// Take first n elements
export proc take(arr, n) {
  return slice(arr, 0, min(n, len(arr)));
}

// Drop first n elements
export proc drop(arr, n) {
  return slice(arr, min(n, len(arr)), len(arr));
}

// Chunk array into groups of size n
export proc chunk(arr, n) {
  let result = [];
  for (i in 0..len(arr)) {
    if (i % n == 0) {
      push(result, []);
    }
    const lastIdx = len(result) - 1;
    push(result[lastIdx], arr[i]);
  }
  return result;
}
