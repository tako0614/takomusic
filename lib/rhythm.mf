// Rhythm generation functions for TakoMusic
// Algorithmic rhythm patterns and timing variations

// euclidean - generate Euclidean rhythm pattern
// Distributes pulses as evenly as possible across steps
export proc euclidean(steps, pulses, dur, pitch) {
  let pattern = [];
  let bucket = 0;

  for (i in 0..steps) {
    bucket = bucket + pulses;
    if (bucket >= steps) {
      bucket = bucket - steps;
      push(pattern, true);
    } else {
      push(pattern, false);
    }
  }

  forEach(pattern, (hit) => {
    if (hit) {
      note(pitch, dur);
    } else {
      rest(dur);
    }
  });
}

// swing - apply swing feel to note sequence
// amount: 0 = straight, 0.33 = triplet swing, 0.5 = extreme swing
export proc swing(notes, dur, amount) {
  forEach(notes, (n, i) => {
    if (i % 2 == 0) {
      const swingDur = dur * (1 + amount);
      note(n, swingDur);
    } else {
      const swingDur = dur * (1 - amount);
      note(n, swingDur);
    }
  });
}

// humanize - add random timing variations
// Adds slight timing offsets to make rhythm feel more human
export proc humanize(notes, dur, amount) {
  forEach(notes, (n) => {
    const offset = (random() - 0.5) * amount;
    const offsetTicks = floor(offset * durToTicks(dur));
    advanceTick(offsetTicks);
    note(n, dur);
  });
}

// shuffle - shuffle rhythm (dotted eighth + sixteenth)
export proc shuffle(notes, dur) {
  forEach(notes, (n, i) => {
    if (i % 2 == 0) {
      note(n, dur * 3/4);
    } else {
      note(n, dur * 1/4);
    }
  });
}

// clave - generate clave rhythm pattern
export proc clave32(pitch, dur) {
  note(pitch, dur);
  rest(dur);
  rest(dur);
  note(pitch, dur);
  rest(dur);
  rest(dur);
  note(pitch, dur);
  rest(dur);

  rest(dur);
  rest(dur);
  note(pitch, dur);
  rest(dur);
  note(pitch, dur);
  rest(dur);
  rest(dur);
  rest(dur);
}

// clave23 - 2-3 clave (reverse)
export proc clave23(pitch, dur) {
  rest(dur);
  rest(dur);
  note(pitch, dur);
  rest(dur);
  note(pitch, dur);
  rest(dur);
  rest(dur);
  rest(dur);

  note(pitch, dur);
  rest(dur);
  rest(dur);
  note(pitch, dur);
  rest(dur);
  rest(dur);
  note(pitch, dur);
  rest(dur);
}

// polyrhythm - play two different rhythms simultaneously
// Returns pattern array for manual track assignment
export proc polyrhythmPattern(steps1, steps2, totalSteps) {
  let pattern1 = [];
  let pattern2 = [];

  for (i in 0..totalSteps) {
    push(pattern1, i % steps1 == 0);
    push(pattern2, i % steps2 == 0);
  }

  return [pattern1, pattern2];
}

// Generate basic drum patterns
export proc basicBeat(kickPitch, snarePitch, hatPitch, dur, bars) {
  const steps = bars * 16;

  for (i in 0..steps) {
    const beat = i % 16;

    // Kick on 1 and 3 (0, 8)
    if (beat == 0 || beat == 8) {
      drum(kickPitch, dur);
    }

    // Snare on 2 and 4 (4, 12)
    if (beat == 4 || beat == 12) {
      drum(snarePitch, dur);
    }

    // Hi-hat on every eighth note
    if (beat % 2 == 0) {
      drum(hatPitch, dur);
    }

    if (beat % 2 == 1) {
      rest(dur);
    }
  }
}

// Apply groove template to notes
// template: array of timing offsets (-1.0 to 1.0)
export proc groove(notes, dur, template) {
  for (i in 0..len(notes)) {
    const templateIdx = i % len(template);
    const offset = template[templateIdx];
    const offsetTicks = floor(offset * durToTicks(dur) / 4);

    if (offsetTicks > 0) {
      advanceTick(offsetTicks);
    }

    note(notes[i], dur);

    if (offsetTicks < 0) {
      advanceTick(-offsetTicks);
    }
  }
}

// Common groove templates
export proc swingGroove() {
  return [0.0, 0.33, 0.0, 0.33];
}

export proc laidBackGroove() {
  return [0.0, 0.1, 0.05, 0.15];
}

export proc pushGroove() {
  return [0.0, -0.1, 0.0, -0.1];
}

// Rubato - expressive timing variation
export proc rubato(notes, baseDur, variation) {
  for (i in 0..len(notes)) {
    const stretch = 1 + (random() - 0.5) * variation;
    const dur = baseDur * stretch;
    note(notes[i], dur);
  }
}

// Accelerando - gradually speed up
export proc accelerando(notes, startDur, endDur) {
  const count = len(notes);
  for (i in 0..count) {
    const t = i / (count - 1);
    const dur = startDur + (endDur - startDur) * t;
    note(notes[i], dur);
  }
}

// Ritardando - gradually slow down
export proc ritardando(notes, startDur, endDur) {
  accelerando(notes, startDur, endDur);
}

// Accelerando with tempo changes
export proc accelerandoTempo(startBpm, endBpm, dur, steps) {
  const ticks = durToTicks(dur);
  const ticksPerStep = floor(ticks / steps);

  for (i in 0..=steps) {
    const t = i / steps;
    const bpm = floor(startBpm + (endBpm - startBpm) * t);
    atTick(i * ticksPerStep);
    tempo(bpm);
  }
}

// Ritardando with tempo changes
export proc ritardandoTempo(startBpm, endBpm, dur, steps) {
  accelerandoTempo(startBpm, endBpm, dur, steps);
}

// Fermata - pause/hold
export proc fermata(pitch, baseDur, holdMultiplier) {
  note(pitch, baseDur * holdMultiplier);
}

// Metric modulation helper
// Returns the new tempo for metric modulation
export proc metricModulation(currentBpm, oldSubdivision, newSubdivision) {
  return floor(currentBpm * oldSubdivision / newSubdivision);
}

// Tuplet rhythm generator
export proc tuplet(notes, totalDur, tupletRatio) {
  const noteDur = totalDur / len(notes);
  for (i in 0..len(notes)) {
    note(notes[i], noteDur);
  }
}

// Triplet
export proc triplet(notes, baseDur) {
  const tripletDur = baseDur * 2 / 3;
  for (i in 0..len(notes)) {
    note(notes[i], tripletDur);
  }
}

// Syncopation pattern
export proc syncopate(notes, dur) {
  for (i in 0..len(notes)) {
    if (i % 2 == 0) {
      rest(dur / 2);
      note(notes[i], dur / 2);
    } else {
      note(notes[i], dur);
    }
  }
}

// Hemiola - 3 against 2
export proc hemiola(notes, dur) {
  const hemiolaDur = dur * 2 / 3;
  for (i in 0..len(notes)) {
    note(notes[i], hemiolaDur);
  }
}
