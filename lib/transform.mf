// std:transform (v3)

fn posToRat(pos) {
  if (pos == null) {
    return null;
  }
  if (pos.kind == "rat") {
    return pos.rat;
  }
  if (pos.kind != null) {
    return null;
  }
  if (pos.n != null && pos.d != null) {
    return pos;
  }
  return null;
}

fn ratToNumber(r) {
  return r.n / r.d;
}

fn floor(value) {
  return value - (value % 1);
}

fn round(value) {
  return floor(value + 0.5);
}

fn ratFromNumber(value) {
  const scaled = round(value * 1000);
  return scaled / 1000;
}

fn scalePos(pos, factor) {
  const r = posToRat(pos);
  if (r == null) {
    return pos;
  }
  return r * factor;
}

fn quantizePos(pos, grid, strength) {
  const r = posToRat(pos);
  if (r == null) {
    return pos;
  }
  const ratio = ratToNumber(r) / ratToNumber(grid);
  const snapped = round(ratio) * ratToNumber(grid);
  if (strength >= 1) {
    return ratFromNumber(snapped);
  }
  const blended = ratToNumber(r) + (snapped - ratToNumber(r)) * strength;
  return ratFromNumber(blended);
}

fn swingPos(pos, grid, amount) {
  const r = posToRat(pos);
  if (r == null) {
    return pos;
  }
  const ratio = ratToNumber(r) / ratToNumber(grid);
  const idx = floor(ratio);
  const isOff = (idx % 2) == 1;
  if (!isOff) {
    return pos;
  }
  const offset = ratToNumber(grid) * amount * 0.5;
  return ratFromNumber(ratToNumber(r) + offset);
}

fn offsetPos(pos, offset) {
  const r = posToRat(pos);
  if (r == null) {
    return pos;
  }
  return ratFromNumber(ratToNumber(r) + offset);
}

fn cloneEvent(ev) {
  if (ev.type == "note") {
    return {
      type: "note",
      start: ev.start,
      dur: ev.dur,
      pitch: ev.pitch,
      velocity: ev.velocity,
      voice: ev.voice,
      techniques: ev.techniques,
      lyric: ev.lyric,
      ext: ev.ext
    };
  }
  if (ev.type == "chord") {
    return {
      type: "chord",
      start: ev.start,
      dur: ev.dur,
      pitches: ev.pitches,
      velocity: ev.velocity,
      voice: ev.voice,
      techniques: ev.techniques,
      ext: ev.ext
    };
  }
  if (ev.type == "drumHit") {
    return {
      type: "drumHit",
      start: ev.start,
      dur: ev.dur,
      key: ev.key,
      velocity: ev.velocity,
      techniques: ev.techniques,
      ext: ev.ext
    };
  }
  if (ev.type == "control") {
    return {
      type: "control",
      start: ev.start,
      kind: ev.kind,
      data: ev.data,
      ext: ev.ext
    };
  }
  if (ev.type == "automation") {
    return {
      type: "automation",
      param: ev.param,
      start: ev.start,
      end: ev.end,
      curve: ev.curve,
      ext: ev.ext
    };
  }
  if (ev.type == "marker") {
    return {
      type: "marker",
      pos: ev.pos,
      kind: ev.kind,
      label: ev.label
    };
  }
  return ev;
}

fn transposeEvent(ev, semitones) {
  let out = cloneEvent(ev);
  if (out.type == "note") {
    out.pitch = out.pitch + semitones;
  }
  if (out.type == "chord") {
    let pitches = [];
    for (p in out.pitches) {
      pitches[pitches.length] = p + semitones;
    }
    out.pitches = pitches;
  }
  return out;
}

fn stretchEvent(ev, factor) {
  let out = cloneEvent(ev);
  if (out.type == "marker") {
    out.pos = scalePos(out.pos, factor);
    return out;
  }
  if (out.type == "automation") {
    out.start = scalePos(out.start, factor);
    out.end = scalePos(out.end, factor);
    return out;
  }
  if (out.type == "note" || out.type == "chord" || out.type == "drumHit") {
    out.start = scalePos(out.start, factor);
    out.dur = out.dur * factor;
    return out;
  }
  if (out.type == "control") {
    out.start = scalePos(out.start, factor);
    return out;
  }
  return out;
}

fn quantizeEvent(ev, grid, strength) {
  let out = cloneEvent(ev);
  if (out.type == "marker") {
    out.pos = quantizePos(out.pos, grid, strength);
    return out;
  }
  if (out.type == "automation") {
    out.start = quantizePos(out.start, grid, strength);
    out.end = quantizePos(out.end, grid, strength);
    return out;
  }
  if (out.start != null) {
    out.start = quantizePos(out.start, grid, strength);
  }
  return out;
}

fn swingEvent(ev, grid, amount) {
  let out = cloneEvent(ev);
  if (out.type == "marker") {
    out.pos = swingPos(out.pos, grid, amount);
    return out;
  }
  if (out.type == "automation") {
    out.start = swingPos(out.start, grid, amount);
    out.end = swingPos(out.end, grid, amount);
    return out;
  }
  if (out.start != null) {
    out.start = swingPos(out.start, grid, amount);
  }
  return out;
}

fn hashFloat(rng, seed) {
  let base = 123456789;
  if (rng != null && rng.state != null) {
    base = rng.state;
  }
  const hashed = (base + seed * 2654435761) % 4294967296;
  return (hashed % 10000) / 10000;
}

fn humanizeEvent(ev, rng, timing, velocity, idx) {
  let out = cloneEvent(ev);
  const jitter = timing * (hashFloat(rng, idx) - 0.5) * 2;
  if (out.type == "marker") {
    out.pos = offsetPos(out.pos, jitter);
    return out;
  }
  if (out.type == "automation") {
    out.start = offsetPos(out.start, jitter);
    out.end = offsetPos(out.end, jitter);
    return out;
  }
  if (out.start != null) {
    out.start = offsetPos(out.start, jitter);
    if (out.velocity != null) {
      const vel = out.velocity;
      out.velocity = vel * (1 + velocity * (hashFloat(rng, idx + 1) - 0.5));
    }
  }
  return out;
}

export fn transpose(c, semitones) {
  let events = [];
  for (ev in c.events) {
    events[events.length] = transposeEvent(ev, semitones);
  }
  return { events: events, length: c.length };
}

export fn stretch(c, factor) {
  let events = [];
  for (ev in c.events) {
    events[events.length] = stretchEvent(ev, factor);
  }
  let length = null;
  if (c.length != null) {
    length = c.length * factor;
  }
  return { events: events, length: length };
}

export fn quantize(c, grid, strength) {
  let amount = strength;
  if (amount == null) {
    amount = 1;
  }
  let events = [];
  for (ev in c.events) {
    events[events.length] = quantizeEvent(ev, grid, amount);
  }
  return { events: events, length: c.length };
}

export fn swing(c, grid, amount) {
  let swingAmount = amount;
  if (swingAmount == null) {
    swingAmount = 0.5;
  }
  let events = [];
  for (ev in c.events) {
    events[events.length] = swingEvent(ev, grid, swingAmount);
  }
  return { events: events, length: c.length };
}

export fn humanize(c, rng, timing, velocity) {
  let timingAmount = timing;
  let v = velocity;
  if (timingAmount == null) {
    timingAmount = 0;
  }
  if (v == null) {
    v = 0;
  }
  let events = [];
  let idx = 0;
  for (ev in c.events) {
    events[events.length] = humanizeEvent(ev, rng, timingAmount, v, idx);
    idx = idx + 1;
  }
  // Update rng state based on number of events processed
  let newState = 123456789;
  if (rng != null && rng.state != null) {
    newState = rng.state;
  }
  const finalState = (newState + idx * 2654435761) % 4294967296;
  const newRng = { state: finalState };
  const clip = { events: events, length: c.length };
  return [newRng, clip];
}
